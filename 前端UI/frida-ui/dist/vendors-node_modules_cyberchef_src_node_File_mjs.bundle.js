/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(global["webpackChunkfrida_ui"] = global["webpackChunkfrida_ui"] || []).push([["vendors-node_modules_cyberchef_src_node_File_mjs"],{

/***/ "./node_modules/cyberchef/src/core/Utils.mjs":
/*!***************************************************!*\
  !*** ./node_modules/cyberchef/src/core/Utils.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   isNodeEnvironment: () => (/* binding */ isNodeEnvironment),\n/* harmony export */   isWebEnvironment: () => (/* binding */ isWebEnvironment),\n/* harmony export */   isWorkerEnvironment: () => (/* binding */ isWorkerEnvironment),\n/* harmony export */   sendStatusMessage: () => (/* binding */ sendStatusMessage)\n/* harmony export */ });\n/* harmony import */ var loglevel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! loglevel */ \"./node_modules/loglevel/lib/loglevel.js\");\n/* harmony import */ var utf8__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! utf8 */ \"./node_modules/utf8/utf8.js\");\n/* harmony import */ var _lib_Base64_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/Base64.mjs */ \"./node_modules/cyberchef/src/core/lib/Base64.mjs\");\n/* harmony import */ var _lib_Hex_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/Hex.mjs */ \"./node_modules/cyberchef/src/core/lib/Hex.mjs\");\n/* harmony import */ var _lib_Decimal_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/Decimal.mjs */ \"./node_modules/cyberchef/src/core/lib/Decimal.mjs\");\n/* harmony import */ var _lib_Binary_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/Binary.mjs */ \"./node_modules/cyberchef/src/core/lib/Binary.mjs\");\n/**\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2016\n * @license Apache-2.0\n */\n\n// loglevel import required for Node API\n\n\n\n\n\n\n\n/**\n * Utility functions for use in operations, the core framework and the stage.\n */\nclass Utils {\n\n    /**\n     * Translates an ordinal into a character.\n     *\n     * @param {number} o\n     * @returns {char}\n     *\n     * @example\n     * // returns 'a'\n     * Utils.chr(97);\n     */\n    static chr(o) {\n        // Detect astral symbols\n        // Thanks to @mathiasbynens for this solution\n        // https://mathiasbynens.be/notes/javascript-unicode\n        if (o > 0xffff) {\n            o -= 0x10000;\n            const high = String.fromCharCode(o >>> 10 & 0x3ff | 0xd800);\n            o = 0xdc00 | o & 0x3ff;\n            return high + String.fromCharCode(o);\n        }\n\n        return String.fromCharCode(o);\n    }\n\n\n    /**\n     * Translates a character into an ordinal.\n     *\n     * @param {char} c\n     * @returns {number}\n     *\n     * @example\n     * // returns 97\n     * Utils.ord('a');\n     */\n    static ord(c) {\n        // Detect astral symbols\n        // Thanks to @mathiasbynens for this solution\n        // https://mathiasbynens.be/notes/javascript-unicode\n        if (c.length === 2) {\n            const high = c.charCodeAt(0);\n            const low = c.charCodeAt(1);\n            if (high >= 0xd800 && high < 0xdc00 &&\n                low >= 0xdc00 && low < 0xe000) {\n                return (high - 0xd800) * 0x400 + low - 0xdc00 + 0x10000;\n            }\n        }\n\n        return c.charCodeAt(0);\n    }\n\n\n    /**\n     * Adds trailing bytes to a byteArray.\n     *\n     * @author tlwr [toby@toby.codes]\n     *\n     * @param {byteArray} arr - byteArray to add trailing bytes to.\n     * @param {number} numBytes - Maximum width of the array.\n     * @param {Integer} [padByte=0] - The byte to pad with.\n     * @returns {byteArray}\n     *\n     * @example\n     * // returns [\"a\", 0, 0, 0]\n     * Utils.padBytesRight(\"a\", 4);\n     *\n     * // returns [\"a\", 1, 1, 1]\n     * Utils.padBytesRight(\"a\", 4, 1);\n     *\n     * // returns [\"t\", \"e\", \"s\", \"t\", 0, 0, 0, 0]\n     * Utils.padBytesRight(\"test\", 8);\n     *\n     * // returns [\"t\", \"e\", \"s\", \"t\", 1, 1, 1, 1]\n     * Utils.padBytesRight(\"test\", 8, 1);\n     */\n    static padBytesRight(arr, numBytes, padByte=0) {\n        const paddedBytes = new Array(numBytes);\n        paddedBytes.fill(padByte);\n\n        [...arr].forEach((b, i) => {\n            paddedBytes[i] = b;\n        });\n\n        return paddedBytes;\n    }\n\n\n    /**\n     * Truncates a long string to max length and adds suffix.\n     *\n     * @param {string} str - String to truncate\n     * @param {number} max - Maximum length of the final string\n     * @param {string} [suffix='...'] - The string to add to the end of the final string\n     * @returns {string}\n     *\n     * @example\n     * // returns \"A long...\"\n     * Utils.truncate(\"A long string\", 9);\n     *\n     * // returns \"A long s-\"\n     * Utils.truncate(\"A long string\", 9, \"-\");\n     */\n    static truncate(str, max, suffix=\"...\") {\n        if (str.length > max) {\n            str = str.slice(0, max - suffix.length) + suffix;\n        }\n        return str;\n    }\n\n\n    /**\n     * Converts a character or number to its hex representation.\n     *\n     * @param {char|number} c\n     * @param {number} [length=2] - The width of the resulting hex number.\n     * @returns {string}\n     *\n     * @example\n     * // returns \"6e\"\n     * Utils.hex(\"n\");\n     *\n     * // returns \"6e\"\n     * Utils.hex(110);\n     */\n    static hex(c, length=2) {\n        c = typeof c == \"string\" ? Utils.ord(c) : c;\n        return c.toString(16).padStart(length, \"0\");\n    }\n\n\n    /**\n     * Converts a character or number to its binary representation.\n     *\n     * @param {char|number} c\n     * @param {number} [length=8] - The width of the resulting binary number.\n     * @returns {string}\n     *\n     * @example\n     * // returns \"01101110\"\n     * Utils.bin(\"n\");\n     *\n     * // returns \"01101110\"\n     * Utils.bin(110);\n     */\n    static bin(c, length=8) {\n        c = typeof c == \"string\" ? Utils.ord(c) : c;\n        return c.toString(2).padStart(length, \"0\");\n    }\n\n\n    /**\n     * Returns a string with all non-printable chars as dots, optionally preserving whitespace.\n     *\n     * @param {string} str - The input string to display.\n     * @param {boolean} [preserveWs=false] - Whether or not to print whitespace.\n     * @param {boolean} [onlyAscii=false] - Whether or not to replace non ASCII characters.\n     * @returns {string}\n     */\n    static printable(str, preserveWs=false, onlyAscii=false) {\n        if (onlyAscii) {\n            return str.replace(/[^\\x20-\\x7f]/g, \".\");\n        }\n\n        // eslint-disable-next-line no-misleading-character-class\n        const re = /[\\0-\\x08\\x0B-\\x0C\\x0E-\\x1F\\x7F-\\x9F\\xAD\\u0378\\u0379\\u037F-\\u0383\\u038B\\u038D\\u03A2\\u0528-\\u0530\\u0557\\u0558\\u0560\\u0588\\u058B-\\u058E\\u0590\\u05C8-\\u05CF\\u05EB-\\u05EF\\u05F5-\\u0605\\u061C\\u061D\\u06DD\\u070E\\u070F\\u074B\\u074C\\u07B2-\\u07BF\\u07FB-\\u07FF\\u082E\\u082F\\u083F\\u085C\\u085D\\u085F-\\u089F\\u08A1\\u08AD-\\u08E3\\u08FF\\u0978\\u0980\\u0984\\u098D\\u098E\\u0991\\u0992\\u09A9\\u09B1\\u09B3-\\u09B5\\u09BA\\u09BB\\u09C5\\u09C6\\u09C9\\u09CA\\u09CF-\\u09D6\\u09D8-\\u09DB\\u09DE\\u09E4\\u09E5\\u09FC-\\u0A00\\u0A04\\u0A0B-\\u0A0E\\u0A11\\u0A12\\u0A29\\u0A31\\u0A34\\u0A37\\u0A3A\\u0A3B\\u0A3D\\u0A43-\\u0A46\\u0A49\\u0A4A\\u0A4E-\\u0A50\\u0A52-\\u0A58\\u0A5D\\u0A5F-\\u0A65\\u0A76-\\u0A80\\u0A84\\u0A8E\\u0A92\\u0AA9\\u0AB1\\u0AB4\\u0ABA\\u0ABB\\u0AC6\\u0ACA\\u0ACE\\u0ACF\\u0AD1-\\u0ADF\\u0AE4\\u0AE5\\u0AF2-\\u0B00\\u0B04\\u0B0D\\u0B0E\\u0B11\\u0B12\\u0B29\\u0B31\\u0B34\\u0B3A\\u0B3B\\u0B45\\u0B46\\u0B49\\u0B4A\\u0B4E-\\u0B55\\u0B58-\\u0B5B\\u0B5E\\u0B64\\u0B65\\u0B78-\\u0B81\\u0B84\\u0B8B-\\u0B8D\\u0B91\\u0B96-\\u0B98\\u0B9B\\u0B9D\\u0BA0-\\u0BA2\\u0BA5-\\u0BA7\\u0BAB-\\u0BAD\\u0BBA-\\u0BBD\\u0BC3-\\u0BC5\\u0BC9\\u0BCE\\u0BCF\\u0BD1-\\u0BD6\\u0BD8-\\u0BE5\\u0BFB-\\u0C00\\u0C04\\u0C0D\\u0C11\\u0C29\\u0C34\\u0C3A-\\u0C3C\\u0C45\\u0C49\\u0C4E-\\u0C54\\u0C57\\u0C5A-\\u0C5F\\u0C64\\u0C65\\u0C70-\\u0C77\\u0C80\\u0C81\\u0C84\\u0C8D\\u0C91\\u0CA9\\u0CB4\\u0CBA\\u0CBB\\u0CC5\\u0CC9\\u0CCE-\\u0CD4\\u0CD7-\\u0CDD\\u0CDF\\u0CE4\\u0CE5\\u0CF0\\u0CF3-\\u0D01\\u0D04\\u0D0D\\u0D11\\u0D3B\\u0D3C\\u0D45\\u0D49\\u0D4F-\\u0D56\\u0D58-\\u0D5F\\u0D64\\u0D65\\u0D76-\\u0D78\\u0D80\\u0D81\\u0D84\\u0D97-\\u0D99\\u0DB2\\u0DBC\\u0DBE\\u0DBF\\u0DC7-\\u0DC9\\u0DCB-\\u0DCE\\u0DD5\\u0DD7\\u0DE0-\\u0DF1\\u0DF5-\\u0E00\\u0E3B-\\u0E3E\\u0E5C-\\u0E80\\u0E83\\u0E85\\u0E86\\u0E89\\u0E8B\\u0E8C\\u0E8E-\\u0E93\\u0E98\\u0EA0\\u0EA4\\u0EA6\\u0EA8\\u0EA9\\u0EAC\\u0EBA\\u0EBE\\u0EBF\\u0EC5\\u0EC7\\u0ECE\\u0ECF\\u0EDA\\u0EDB\\u0EE0-\\u0EFF\\u0F48\\u0F6D-\\u0F70\\u0F98\\u0FBD\\u0FCD\\u0FDB-\\u0FFF\\u10C6\\u10C8-\\u10CC\\u10CE\\u10CF\\u1249\\u124E\\u124F\\u1257\\u1259\\u125E\\u125F\\u1289\\u128E\\u128F\\u12B1\\u12B6\\u12B7\\u12BF\\u12C1\\u12C6\\u12C7\\u12D7\\u1311\\u1316\\u1317\\u135B\\u135C\\u137D-\\u137F\\u139A-\\u139F\\u13F5-\\u13FF\\u169D-\\u169F\\u16F1-\\u16FF\\u170D\\u1715-\\u171F\\u1737-\\u173F\\u1754-\\u175F\\u176D\\u1771\\u1774-\\u177F\\u17DE\\u17DF\\u17EA-\\u17EF\\u17FA-\\u17FF\\u180F\\u181A-\\u181F\\u1878-\\u187F\\u18AB-\\u18AF\\u18F6-\\u18FF\\u191D-\\u191F\\u192C-\\u192F\\u193C-\\u193F\\u1941-\\u1943\\u196E\\u196F\\u1975-\\u197F\\u19AC-\\u19AF\\u19CA-\\u19CF\\u19DB-\\u19DD\\u1A1C\\u1A1D\\u1A5F\\u1A7D\\u1A7E\\u1A8A-\\u1A8F\\u1A9A-\\u1A9F\\u1AAE-\\u1AFF\\u1B4C-\\u1B4F\\u1B7D-\\u1B7F\\u1BF4-\\u1BFB\\u1C38-\\u1C3A\\u1C4A-\\u1C4C\\u1C80-\\u1CBF\\u1CC8-\\u1CCF\\u1CF7-\\u1CFF\\u1DE7-\\u1DFB\\u1F16\\u1F17\\u1F1E\\u1F1F\\u1F46\\u1F47\\u1F4E\\u1F4F\\u1F58\\u1F5A\\u1F5C\\u1F5E\\u1F7E\\u1F7F\\u1FB5\\u1FC5\\u1FD4\\u1FD5\\u1FDC\\u1FF0\\u1FF1\\u1FF5\\u1FFF\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u2072\\u2073\\u208F\\u209D-\\u209F\\u20BB-\\u20CF\\u20F1-\\u20FF\\u218A-\\u218F\\u23F4-\\u23FF\\u2427-\\u243F\\u244B-\\u245F\\u2700\\u2B4D-\\u2B4F\\u2B5A-\\u2BFF\\u2C2F\\u2C5F\\u2CF4-\\u2CF8\\u2D26\\u2D28-\\u2D2C\\u2D2E\\u2D2F\\u2D68-\\u2D6E\\u2D71-\\u2D7E\\u2D97-\\u2D9F\\u2DA7\\u2DAF\\u2DB7\\u2DBF\\u2DC7\\u2DCF\\u2DD7\\u2DDF\\u2E3C-\\u2E7F\\u2E9A\\u2EF4-\\u2EFF\\u2FD6-\\u2FEF\\u2FFC-\\u2FFF\\u3040\\u3097\\u3098\\u3100-\\u3104\\u312E-\\u3130\\u318F\\u31BB-\\u31BF\\u31E4-\\u31EF\\u321F\\u32FF\\u4DB6-\\u4DBF\\u9FCD-\\u9FFF\\uA48D-\\uA48F\\uA4C7-\\uA4CF\\uA62C-\\uA63F\\uA698-\\uA69E\\uA6F8-\\uA6FF\\uA78F\\uA794-\\uA79F\\uA7AB-\\uA7F7\\uA82C-\\uA82F\\uA83A-\\uA83F\\uA878-\\uA87F\\uA8C5-\\uA8CD\\uA8DA-\\uA8DF\\uA8FC-\\uA8FF\\uA954-\\uA95E\\uA97D-\\uA97F\\uA9CE\\uA9DA-\\uA9DD\\uA9E0-\\uA9FF\\uAA37-\\uAA3F\\uAA4E\\uAA4F\\uAA5A\\uAA5B\\uAA7C-\\uAA7F\\uAAC3-\\uAADA\\uAAF7-\\uAB00\\uAB07\\uAB08\\uAB0F\\uAB10\\uAB17-\\uAB1F\\uAB27\\uAB2F-\\uABBF\\uABEE\\uABEF\\uABFA-\\uABFF\\uD7A4-\\uD7AF\\uD7C7-\\uD7CA\\uD7FC-\\uD7FF\\uE000-\\uF8FF\\uFA6E\\uFA6F\\uFADA-\\uFAFF\\uFB07-\\uFB12\\uFB18-\\uFB1C\\uFB37\\uFB3D\\uFB3F\\uFB42\\uFB45\\uFBC2-\\uFBD2\\uFD40-\\uFD4F\\uFD90\\uFD91\\uFDC8-\\uFDEF\\uFDFE\\uFDFF\\uFE1A-\\uFE1F\\uFE27-\\uFE2F\\uFE53\\uFE67\\uFE6C-\\uFE6F\\uFE75\\uFEFD-\\uFF00\\uFFBF-\\uFFC1\\uFFC8\\uFFC9\\uFFD0\\uFFD1\\uFFD8\\uFFD9\\uFFDD-\\uFFDF\\uFFE7\\uFFEF-\\uFFFB\\uFFFE\\uFFFF]/g;\n        const wsRe = /[\\x09-\\x10\\u2028\\u2029]/g;\n\n        str = str.replace(re, \".\");\n        if (!preserveWs) str = str.replace(wsRe, \".\");\n        return str;\n    }\n\n\n    /**\n     * Returns a string with whitespace represented as special characters from the\n     * Unicode Private Use Area, which CyberChef will display as control characters.\n     * Private Use Area characters are in the range U+E000..U+F8FF.\n     * https://en.wikipedia.org/wiki/Private_Use_Areas\n     * @param {string} str\n     * @returns {string}\n     */\n    static escapeWhitespace(str) {\n        return str.replace(/[\\x09-\\x10]/g, function(c) {\n            return String.fromCharCode(0xe000 + c.charCodeAt(0));\n        });\n    }\n\n\n    /**\n     * Parse a string entered by a user and replace escaped chars with the bytes they represent.\n     *\n     * @param {string} str\n     * @returns {string}\n     *\n     * @example\n     * // returns \"\\x00\"\n     * Utils.parseEscapedChars(\"\\\\x00\");\n     *\n     * // returns \"\\n\"\n     * Utils.parseEscapedChars(\"\\\\n\");\n     */\n    static parseEscapedChars(str) {\n        return str.replace(/\\\\([abfnrtv'\"]|[0-3][0-7]{2}|[0-7]{1,2}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u\\{[\\da-fA-F]{1,6}\\}|\\\\)/g, function(m, a) {\n            switch (a[0]) {\n                case \"\\\\\":\n                    return \"\\\\\";\n                case \"0\":\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                    return String.fromCharCode(parseInt(a, 8));\n                case \"a\":\n                    return String.fromCharCode(7);\n                case \"b\":\n                    return \"\\b\";\n                case \"t\":\n                    return \"\\t\";\n                case \"n\":\n                    return \"\\n\";\n                case \"v\":\n                    return \"\\v\";\n                case \"f\":\n                    return \"\\f\";\n                case \"r\":\n                    return \"\\r\";\n                case '\"':\n                    return '\"';\n                case \"'\":\n                    return \"'\";\n                case \"x\":\n                    return String.fromCharCode(parseInt(a.substr(1), 16));\n                case \"u\":\n                    if (a[1] === \"{\")\n                        return String.fromCodePoint(parseInt(a.slice(2, -1), 16));\n                    else\n                        return String.fromCharCode(parseInt(a.substr(1), 16));\n            }\n        });\n    }\n\n\n    /**\n     * Escape a string containing regex control characters so that it can be safely\n     * used in a regex without causing unintended behaviours.\n     *\n     * @param {string} str\n     * @returns {string}\n     *\n     * @example\n     * // returns \"\\[example\\]\"\n     * Utils.escapeRegex(\"[example]\");\n     */\n    static escapeRegex(str) {\n        return str.replace(/([.*+?^=!:${}()|[\\]/\\\\])/g, \"\\\\$1\");\n    }\n\n\n    /**\n     * Expand an alphabet range string into a list of the characters in that range.\n     *\n     * @param {string} alphStr\n     * @returns {char[]}\n     *\n     * @example\n     * // returns [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n     * Utils.expandAlphRange(\"0-9\");\n     *\n     * // returns [\"a\", \"b\", \"c\", \"d\", \"0\", \"1\", \"2\", \"3\", \"+\", \"/\"]\n     * Utils.expandAlphRange(\"a-d0-3+/\");\n     *\n     * // returns [\"a\", \"b\", \"c\", \"d\", \"0\", \"-\", \"3\"]\n     * Utils.expandAlphRange(\"a-d0\\\\-3\")\n     */\n    static expandAlphRange(alphStr) {\n        const alphArr = [];\n\n        for (let i = 0; i < alphStr.length; i++) {\n            if (i < alphStr.length - 2 &&\n                alphStr[i+1] === \"-\" &&\n                alphStr[i] !== \"\\\\\") {\n                const start = Utils.ord(alphStr[i]),\n                    end = Utils.ord(alphStr[i+2]);\n\n                for (let j = start; j <= end; j++) {\n                    alphArr.push(Utils.chr(j));\n                }\n                i += 2;\n            } else if (i < alphStr.length - 2 &&\n                alphStr[i] === \"\\\\\" &&\n                alphStr[i+1] === \"-\") {\n                alphArr.push(\"-\");\n                i++;\n            } else {\n                alphArr.push(alphStr[i]);\n            }\n        }\n        return alphArr;\n    }\n\n\n    /**\n     * Coverts data of varying types to a byteArray.\n     * Accepts hex, Base64, UTF8 and Latin1 strings.\n     *\n     * @param {string} str\n     * @param {string} type - One of \"Binary\", \"Hex\", \"Decimal\", \"Base64\", \"UTF8\" or \"Latin1\"\n     * @returns {byteArray}\n     *\n     * @example\n     * // returns [208, 159, 209, 128, 208, 184, 208, 178, 208, 181, 209, 130]\n     * Utils.convertToByteArray(\"Привет\", \"utf8\");\n     *\n     * // returns [208, 159, 209, 128, 208, 184, 208, 178, 208, 181, 209, 130]\n     * Utils.convertToByteArray(\"d097d0b4d180d0b0d0b2d181d182d0b2d183d0b9d182d0b5\", \"hex\");\n     *\n     * // returns [208, 159, 209, 128, 208, 184, 208, 178, 208, 181, 209, 130]\n     * Utils.convertToByteArray(\"0JfQtNGA0LDQstGB0YLQstGD0LnRgtC1\", \"base64\");\n     */\n    static convertToByteArray(str, type) {\n        switch (type.toLowerCase()) {\n            case \"binary\":\n                return (0,_lib_Binary_mjs__WEBPACK_IMPORTED_MODULE_5__.fromBinary)(str);\n            case \"hex\":\n                return (0,_lib_Hex_mjs__WEBPACK_IMPORTED_MODULE_3__.fromHex)(str);\n            case \"decimal\":\n                return (0,_lib_Decimal_mjs__WEBPACK_IMPORTED_MODULE_4__.fromDecimal)(str);\n            case \"base64\":\n                return (0,_lib_Base64_mjs__WEBPACK_IMPORTED_MODULE_2__.fromBase64)(str, null, \"byteArray\");\n            case \"utf8\":\n                return Utils.strToUtf8ByteArray(str);\n            case \"latin1\":\n            default:\n                return Utils.strToByteArray(str);\n        }\n    }\n\n\n    /**\n     * Coverts data of varying types to a byte string.\n     * Accepts hex, Base64, UTF8 and Latin1 strings.\n     *\n     * @param {string} str\n     * @param {string} type - One of \"Binary\", \"Hex\", \"Decimal\", \"Base64\", \"UTF8\" or \"Latin1\"\n     * @returns {string}\n     *\n     * @example\n     * // returns \"ÐÑÐ¸Ð²ÐµÑ\"\n     * Utils.convertToByteString(\"Привет\", \"utf8\");\n     *\n     * // returns \"ÐÐ´ÑÐ°Ð²ÑÑÐ²ÑÐ¹ÑÐµ\"\n     * Utils.convertToByteString(\"d097d0b4d180d0b0d0b2d181d182d0b2d183d0b9d182d0b5\", \"hex\");\n     *\n     * // returns \"ÐÐ´ÑÐ°Ð²ÑÑÐ²ÑÐ¹ÑÐµ\"\n     * Utils.convertToByteString(\"0JfQtNGA0LDQstGB0YLQstGD0LnRgtC1\", \"base64\");\n     */\n    static convertToByteString(str, type) {\n        switch (type.toLowerCase()) {\n            case \"binary\":\n                return Utils.byteArrayToChars((0,_lib_Binary_mjs__WEBPACK_IMPORTED_MODULE_5__.fromBinary)(str));\n            case \"hex\":\n                return Utils.byteArrayToChars((0,_lib_Hex_mjs__WEBPACK_IMPORTED_MODULE_3__.fromHex)(str));\n            case \"decimal\":\n                return Utils.byteArrayToChars((0,_lib_Decimal_mjs__WEBPACK_IMPORTED_MODULE_4__.fromDecimal)(str));\n            case \"base64\":\n                return Utils.byteArrayToChars((0,_lib_Base64_mjs__WEBPACK_IMPORTED_MODULE_2__.fromBase64)(str, null, \"byteArray\"));\n            case \"utf8\":\n                return utf8__WEBPACK_IMPORTED_MODULE_1__.encode(str);\n            case \"latin1\":\n            default:\n                return str;\n        }\n    }\n\n\n    /**\n     * Converts a byte array to an integer.\n     *\n     * @param {byteArray} byteArray\n     * @param {string} byteorder - \"little\" or \"big\"\n     * @returns {integer}\n     *\n     * @example\n     * // returns 67305985\n     * Utils.byteArrayToInt([1, 2, 3, 4], \"little\");\n     *\n     * // returns 16909060\n     * Utils.byteArrayToInt([1, 2, 3, 4], \"big\");\n     */\n    static byteArrayToInt(byteArray, byteorder) {\n        let value = 0;\n        if (byteorder === \"big\") {\n            for (let i = 0; i < byteArray.length; i++) {\n                value = (value * 256) + byteArray[i];\n            }\n        } else {\n            for (let i = byteArray.length - 1; i >= 0; i--) {\n                value = (value * 256) + byteArray[i];\n            }\n        }\n        return value;\n    }\n\n\n    /**\n     * Converts an integer to a byte array of {length} bytes.\n     *\n     * @param {integer} value\n     * @param {integer} length\n     * @param {string} byteorder - \"little\" or \"big\"\n     * @returns {byteArray}\n     *\n     * @example\n     * // returns [5, 255, 109, 1]\n     * Utils.intToByteArray(23985925, 4, \"little\");\n     *\n     * // returns [1, 109, 255, 5]\n     * Utils.intToByteArray(23985925, 4, \"big\");\n     *\n     * // returns [0, 0, 0, 0, 1, 109, 255, 5]\n     * Utils.intToByteArray(23985925, 8, \"big\");\n     */\n    static intToByteArray(value, length, byteorder) {\n        const arr = new Array(length);\n        if (byteorder === \"little\") {\n            for (let i = 0; i < length; i++) {\n                arr[i] = value & 0xFF;\n                value = value >>> 8;\n            }\n        } else {\n            for (let i = length - 1; i >= 0; i--) {\n                arr[i] = value & 0xFF;\n                value = value >>> 8;\n            }\n        }\n        return arr;\n    }\n\n\n    /**\n     * Converts a string to an ArrayBuffer.\n     * Treats the string as UTF-8 if any values are over 255.\n     *\n     * @param {string} str\n     * @returns {ArrayBuffer}\n     *\n     * @example\n     * // returns [72,101,108,108,111]\n     * Utils.strToArrayBuffer(\"Hello\");\n     *\n     * // returns [228,189,160,229,165,189]\n     * Utils.strToArrayBuffer(\"你好\");\n     */\n    static strToArrayBuffer(str) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting string[${str?.length}] to array buffer`);\n        if (!str) return new ArrayBuffer;\n\n        const arr = new Uint8Array(str.length);\n        let i = str.length, b;\n        while (i--) {\n            b = str.charCodeAt(i);\n            arr[i] = b;\n            // If any of the bytes are over 255, read as UTF-8\n            if (b > 255) return Utils.strToUtf8ArrayBuffer(str);\n        }\n        return arr.buffer;\n    }\n\n\n    /**\n     * Converts a string to a UTF-8 ArrayBuffer.\n     *\n     * @param {string} str\n     * @returns {ArrayBuffer}\n     *\n     * @example\n     * // returns [72,101,108,108,111]\n     * Utils.strToUtf8ArrayBuffer(\"Hello\");\n     *\n     * // returns [228,189,160,229,165,189]\n     * Utils.strToUtf8ArrayBuffer(\"你好\");\n     */\n    static strToUtf8ArrayBuffer(str) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting string[${str?.length}] to UTF8 array buffer`);\n        if (!str) return new ArrayBuffer;\n\n        const buffer = new TextEncoder(\"utf-8\").encode(str);\n\n        if (str.length !== buffer.length) {\n            if (isWorkerEnvironment() && self && typeof self.setOption === \"function\") {\n                self.setOption(\"attemptHighlight\", false);\n            } else if (isWebEnvironment()) {\n                window.app.options.attemptHighlight = false;\n            }\n        }\n\n        return buffer.buffer;\n    }\n\n\n    /**\n     * Converts a string to a byte array.\n     * Treats the string as UTF-8 if any values are over 255.\n     *\n     * @param {string} str\n     * @returns {byteArray}\n     *\n     * @example\n     * // returns [72,101,108,108,111]\n     * Utils.strToByteArray(\"Hello\");\n     *\n     * // returns [228,189,160,229,165,189]\n     * Utils.strToByteArray(\"你好\");\n     */\n    static strToByteArray(str) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting string[${str?.length}] to byte array`);\n        if (!str) return [];\n        const byteArray = new Array(str.length);\n        let i = str.length, b;\n        while (i--) {\n            b = str.charCodeAt(i);\n            byteArray[i] = b;\n            // If any of the bytes are over 255, read as UTF-8\n            if (b > 255) return Utils.strToUtf8ByteArray(str);\n        }\n        return byteArray;\n    }\n\n\n    /**\n     * Converts a string to a UTF-8 byte array.\n     *\n     * @param {string} str\n     * @returns {byteArray}\n     *\n     * @example\n     * // returns [72,101,108,108,111]\n     * Utils.strToUtf8ByteArray(\"Hello\");\n     *\n     * // returns [228,189,160,229,165,189]\n     * Utils.strToUtf8ByteArray(\"你好\");\n     */\n    static strToUtf8ByteArray(str) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting string[${str?.length}] to UTF8 byte array`);\n        if (!str) return [];\n        const utf8Str = utf8__WEBPACK_IMPORTED_MODULE_1__.encode(str);\n\n        if (str.length !== utf8Str.length) {\n            if (isWorkerEnvironment()) {\n                self.setOption(\"attemptHighlight\", false);\n            } else if (isWebEnvironment()) {\n                window.app.options.attemptHighlight = false;\n            }\n        }\n\n        return Utils.strToByteArray(utf8Str);\n    }\n\n\n    /**\n     * Converts a string to a unicode charcode array\n     *\n     * @param {string} str\n     * @returns {byteArray}\n     *\n     * @example\n     * // returns [72,101,108,108,111]\n     * Utils.strToCharcode(\"Hello\");\n     *\n     * // returns [20320,22909]\n     * Utils.strToCharcode(\"你好\");\n     */\n    static strToCharcode(str) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting string[${str?.length}] to charcode`);\n        if (!str) return [];\n        const charcode = [];\n\n        for (let i = 0; i < str.length; i++) {\n            let ord = str.charCodeAt(i);\n\n            // Detect and merge astral symbols\n            if (i < str.length - 1 && ord >= 0xd800 && ord < 0xdc00) {\n                const low = str[i + 1].charCodeAt(0);\n                if (low >= 0xdc00 && low < 0xe000) {\n                    ord = Utils.ord(str[i] + str[++i]);\n                }\n            }\n\n            charcode.push(ord);\n        }\n\n        return charcode;\n    }\n\n\n    /**\n     * Attempts to convert a byte array to a UTF-8 string.\n     *\n     * @param {byteArray|Uint8Array} byteArray\n     * @returns {string}\n     *\n     * @example\n     * // returns \"Hello\"\n     * Utils.byteArrayToUtf8([72,101,108,108,111]);\n     *\n     * // returns \"你好\"\n     * Utils.byteArrayToUtf8([228,189,160,229,165,189]);\n     */\n    static byteArrayToUtf8(byteArray) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting byte array[${byteArray?.length}] to UTF8`);\n        if (!byteArray || !byteArray.length) return \"\";\n        if (!(byteArray instanceof Uint8Array))\n            byteArray = new Uint8Array(byteArray);\n\n        try {\n            const str = new TextDecoder(\"utf-8\", {fatal: true}).decode(byteArray);\n\n            if (str.length !== byteArray.length) {\n                if (isWorkerEnvironment()) {\n                    self.setOption(\"attemptHighlight\", false);\n                } else if (isWebEnvironment()) {\n                    window.app.options.attemptHighlight = false;\n                }\n            }\n\n            return str;\n        } catch (err) {\n            // If it fails, treat it as ANSI\n            return Utils.byteArrayToChars(byteArray);\n        }\n    }\n\n\n    /**\n     * Converts a charcode array to a string.\n     *\n     * @param {byteArray|Uint8Array} byteArray\n     * @returns {string}\n     *\n     * @example\n     * // returns \"Hello\"\n     * Utils.byteArrayToChars([72,101,108,108,111]);\n     *\n     * // returns \"你好\"\n     * Utils.byteArrayToChars([20320,22909]);\n     */\n    static byteArrayToChars(byteArray) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting byte array[${byteArray?.length}] to chars`);\n        if (!byteArray || !byteArray.length) return \"\";\n        let str = \"\";\n        // Maxiumum arg length for fromCharCode is 65535, but the stack may already be fairly deep,\n        // so don't get too near it.\n        for (let i = 0; i < byteArray.length; i += 20000) {\n            str += String.fromCharCode(...(byteArray.slice(i, i+20000)));\n        }\n        return str;\n    }\n\n\n    /**\n     * Converts an ArrayBuffer to a string.\n     *\n     * @param {ArrayBuffer} arrayBuffer\n     * @param {boolean} [utf8=true] - Whether to attempt to decode the buffer as UTF-8\n     * @returns {string}\n     *\n     * @example\n     * // returns \"hello\"\n     * Utils.arrayBufferToStr(Uint8Array.from([104,101,108,108,111]).buffer);\n     */\n    static arrayBufferToStr(arrayBuffer, utf8=true) {\n        loglevel__WEBPACK_IMPORTED_MODULE_0__.debug(`Converting array buffer[${arrayBuffer?.byteLength}] to str`);\n        if (!arrayBuffer || !arrayBuffer.byteLength) return \"\";\n        const arr = new Uint8Array(arrayBuffer);\n        return utf8 ? Utils.byteArrayToUtf8(arr) : Utils.byteArrayToChars(arr);\n    }\n\n    /**\n     * Calculates the Shannon entropy for a given set of data.\n     *\n     * @param {Uint8Array|ArrayBuffer} input\n     * @returns {number}\n     */\n    static calculateShannonEntropy(data) {\n        if (data instanceof ArrayBuffer) {\n            data = new Uint8Array(data);\n        }\n        const prob = [],\n            occurrences = new Array(256).fill(0);\n\n        // Count occurrences of each byte in the input\n        let i;\n        for (i = 0; i < data.length; i++) {\n            occurrences[data[i]]++;\n        }\n\n        // Store probability list\n        for (i = 0; i < occurrences.length; i++) {\n            if (occurrences[i] > 0) {\n                prob.push(occurrences[i] / data.length);\n            }\n        }\n\n        // Calculate Shannon entropy\n        let entropy = 0,\n            p;\n\n        for (i = 0; i < prob.length; i++) {\n            p = prob[i];\n            entropy += p * Math.log(p) / Math.log(2);\n        }\n\n        return -entropy;\n    }\n\n\n    /**\n     * Parses CSV data and returns it as a two dimensional array or strings.\n     *\n     * @param {string} data\n     * @param {string[]} [cellDelims=[\",\"]]\n     * @param {string[]} [lineDelims=[\"\\n\", \"\\r\"]]\n     * @returns {string[][]}\n     *\n     * @example\n     * // returns [[\"head1\", \"head2\"], [\"data1\", \"data2\"]]\n     * Utils.parseCSV(\"head1,head2\\ndata1,data2\");\n     */\n    static parseCSV(data, cellDelims=[\",\"], lineDelims=[\"\\n\", \"\\r\"]) {\n        let b,\n            next,\n            renderNext = false,\n            inString = false,\n            cell = \"\",\n            line = [];\n        const lines = [];\n\n        // Remove BOM, often present in Excel CSV files\n        if (data.length && data[0] === \"\\uFEFF\") data = data.substr(1);\n\n        for (let i = 0; i < data.length; i++) {\n            b = data[i];\n            next = data[i+1] || \"\";\n            if (renderNext) {\n                cell += b;\n                renderNext = false;\n            } else if (b === \"\\\"\" && !inString) {\n                inString = true;\n            } else if (b === \"\\\"\" && inString) {\n                if (next === \"\\\"\") renderNext = true;\n                else inString = false;\n            } else if (!inString && cellDelims.indexOf(b) >= 0) {\n                line.push(cell);\n                cell = \"\";\n            } else if (!inString && lineDelims.indexOf(b) >= 0) {\n                line.push(cell);\n                cell = \"\";\n                lines.push(line);\n                line = [];\n                // Skip next byte if it is also a line delim (e.g. \\r\\n)\n                if (lineDelims.indexOf(next) >= 0 && next !== b) {\n                    i++;\n                }\n            } else {\n                cell += b;\n            }\n        }\n\n        if (line.length) {\n            line.push(cell);\n            lines.push(line);\n        }\n\n        return lines;\n    }\n\n\n    /**\n     * Removes all HTML (or XML) tags from the input string.\n     *\n     * @param {string} htmlStr\n     * @param {boolean} [removeScriptAndStyle=false]\n     *     - Flag to specify whether to remove entire script or style blocks\n     * @returns {string}\n     *\n     * @example\n     * // returns \"Test\"\n     * Utils.stripHtmlTags(\"<div>Test</div>\");\n     */\n    static stripHtmlTags(htmlStr, removeScriptAndStyle=false) {\n        /**\n         * Recursively remove a pattern from a string until there are no more matches.\n         * Avoids incomplete sanitization e.g. \"aabcbc\".replace(/abc/g, \"\") === \"abc\"\n         *\n         * @param {RegExp} pattern\n         * @param {string} str\n         * @returns {string}\n         */\n        function recursiveRemove(pattern, str) {\n            const newStr = str.replace(pattern, \"\");\n            return newStr.length === str.length ? newStr : recursiveRemove(pattern, newStr);\n        }\n\n        if (removeScriptAndStyle) {\n            htmlStr = recursiveRemove(/<script[^>]*>(\\s|\\S)*?<\\/script[^>]*>/gi, htmlStr);\n            htmlStr = recursiveRemove(/<style[^>]*>(\\s|\\S)*?<\\/style[^>]*>/gi, htmlStr);\n        }\n        return recursiveRemove(/<[^>]+>/g, htmlStr);\n    }\n\n\n    /**\n     * Escapes HTML tags in a string to stop them being rendered.\n     * https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet\n     *\n     * Null bytes are a special case and are converted to a character from the Unicode\n     * Private Use Area, which CyberChef will display as a control character picture.\n     * This is done due to null bytes not being rendered or stored correctly in HTML\n     * DOM building.\n     *\n     * @param {string} str\n     * @returns string\n     *\n     * @example\n     * // return \"A &lt;script&gt; tag\"\n     * Utils.escapeHtml(\"A <script> tag\");\n     */\n    static escapeHtml(str) {\n        const HTML_CHARS = {\n            \"&\": \"&amp;\",\n            \"<\": \"&lt;\",\n            \">\": \"&gt;\",\n            '\"': \"&quot;\",\n            \"'\": \"&#x27;\", // &apos; not recommended because it's not in the HTML spec\n            \"`\": \"&#x60;\",\n            \"\\u0000\": \"\\ue000\"\n        };\n\n        return str ? str.replace(/[&<>\"'`\\u0000]/g, function (match) {\n            return HTML_CHARS[match];\n        }) : str;\n    }\n\n\n    /**\n     * Unescapes HTML tags in a string to make them render again.\n     *\n     * @param {string} str\n     * @returns string\n     *\n     * @example\n     * // return \"A <script> tag\"\n     * Utils.unescapeHtml(\"A &lt;script&gt; tag\");\n     */\n    static unescapeHtml(str) {\n        const HTML_CHARS = {\n            \"&amp;\":  \"&\",\n            \"&lt;\":   \"<\",\n            \"&gt;\":   \">\",\n            \"&quot;\": '\"',\n            \"&#x27;\": \"'\",\n            \"&#x2F;\": \"/\",\n            \"&#x60;\": \"`\",\n            \"\\ue000\": \"\\u0000\"\n        };\n\n        return str.replace(/(&#?x?[a-z0-9]{2,4};|\\ue000)/ig, function (match) {\n            return HTML_CHARS[match] || match;\n        });\n    }\n\n\n    /**\n     * Converts a string to its title case equivalent.\n     *\n     * @param {string} str\n     * @returns string\n     *\n     * @example\n     * // return \"A Tiny String\"\n     * Utils.toTitleCase(\"a tIny String\");\n     */\n    static toTitleCase(str) {\n        return str.replace(/\\w\\S*/g, function(txt) {\n            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n        });\n    }\n\n\n    /**\n     * Encodes a URI fragment (#) or query (?) using a minimal amount of percent-encoding.\n     *\n     * RFC 3986 defines legal characters for the fragment and query parts of a URL to be as follows:\n     *\n     * fragment      = *( pchar / \"/\" / \"?\" )\n     * query         = *( pchar / \"/\" / \"?\" )\n     * pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     * unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     * pct-encoded   = \"%\" HEXDIG HEXDIG\n     * sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n     *                  / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     *\n     * Meaning that the list of characters that need not be percent-encoded are alphanumeric plus:\n     * -._~!$&'()*+,;=:@/?\n     *\n     * & and = are still escaped as they are used to serialise the key-value pairs in CyberChef\n     * fragments. + is also escaped so as to prevent it being decoded to a space.\n     *\n     * @param {string} str\n     * @returns {string}\n     */\n    static encodeURIFragment(str) {\n        const LEGAL_CHARS = {\n            \"%2D\": \"-\",\n            \"%2E\": \".\",\n            \"%5F\": \"_\",\n            \"%7E\": \"~\",\n            \"%21\": \"!\",\n            \"%24\": \"$\",\n            // \"%26\": \"&\",\n            \"%27\": \"'\",\n            \"%28\": \"(\",\n            \"%29\": \")\",\n            \"%2A\": \"*\",\n            // \"%2B\": \"+\",\n            \"%2C\": \",\",\n            \"%3B\": \";\",\n            // \"%3D\": \"=\",\n            \"%3A\": \":\",\n            \"%40\": \"@\",\n            \"%2F\": \"/\",\n            \"%3F\": \"?\"\n        };\n        str = encodeURIComponent(str);\n\n        return str.replace(/%[0-9A-F]{2}/g, function (match) {\n            return LEGAL_CHARS[match] || match;\n        });\n    }\n\n\n    /**\n     * Generates a \"pretty\" recipe format from a recipeConfig object.\n     *\n     * \"Pretty\" CyberChef recipe formats are designed to be included in the fragment (#) or query (?)\n     * parts of the URL. They can also be loaded into CyberChef through the 'Load' interface. In order\n     * to make this format as readable as possible, various special characters are used unescaped. This\n     * reduces the amount of percent-encoding included in the URL which is typically difficult to read\n     * and substantially increases the overall length. These characteristics can be quite off-putting\n     * for users.\n     *\n     * @param {Object[]} recipeConfig\n     * @param {boolean} [newline=false] - whether to add a newline after each operation\n     * @returns {string}\n     */\n    static generatePrettyRecipe(recipeConfig, newline = false) {\n        let prettyConfig = \"\",\n            name = \"\",\n            args = \"\",\n            disabled = \"\",\n            bp = \"\";\n\n        recipeConfig.forEach(op => {\n            name = op.op.replace(/ /g, \"_\");\n            args = JSON.stringify(op.args)\n                .slice(1, -1) // Remove [ and ] as they are implied\n                // We now need to switch double-quoted (\") strings to single quotes (') as single quotes\n                // do not need to be percent-encoded.\n                .replace(/'/g, \"\\\\'\") // Escape single quotes\n                .replace(/\"((?:[^\"\\\\]|\\\\.)*)\"/g, \"'$1'\") // Replace opening and closing \" with '\n                .replace(/\\\\\"/g, '\"'); // Unescape double quotes\n\n            disabled = op.disabled ? \"/disabled\": \"\";\n            bp = op.breakpoint ? \"/breakpoint\" : \"\";\n            prettyConfig += `${name}(${args}${disabled}${bp})`;\n            if (newline) prettyConfig += \"\\n\";\n        });\n        return prettyConfig;\n    }\n\n\n    /**\n     * Converts a recipe string to the JSON representation of the recipe.\n     * Accepts either stringified JSON or the bespoke \"pretty\" recipe format.\n     *\n     * @param {string} recipe\n     * @returns {Object[]}\n     */\n    static parseRecipeConfig(recipe) {\n        recipe = recipe.trim();\n        if (recipe.length === 0) return [];\n        if (recipe[0] === \"[\") return JSON.parse(recipe);\n\n        // Parse bespoke recipe format\n        recipe = recipe.replace(/\\n/g, \"\");\n        let m, args;\n        const recipeRegex = /([^(]+)\\(((?:'[^'\\\\]*(?:\\\\.[^'\\\\]*)*'|[^)/'])*)(\\/[^)]+)?\\)/g,\n            recipeConfig = [];\n\n        while ((m = recipeRegex.exec(recipe))) {\n            // Translate strings in args back to double-quotes\n            args = m[2] // lgtm [js/incomplete-sanitization]\n                .replace(/\"/g, '\\\\\"') // Escape double quotes\n                .replace(/(^|,|{|:)'/g, '$1\"') // Replace opening ' with \"\n                .replace(/([^\\\\]|(?:\\\\\\\\)+)'(,|:|}|$)/g, '$1\"$2') // Replace closing ' with \"\n                .replace(/\\\\'/g, \"'\"); // Unescape single quotes\n            args = \"[\" + args + \"]\";\n\n            const op = {\n                op: m[1].replace(/_/g, \" \"),\n                args: JSON.parse(args)\n            };\n            if (m[3] && m[3].indexOf(\"disabled\") > 0) op.disabled = true;\n            if (m[3] && m[3].indexOf(\"breakpoint\") > 0) op.breakpoint = true;\n            recipeConfig.push(op);\n        }\n        return recipeConfig;\n    }\n\n\n    /**\n     * Formats a list of files or directories.\n     *\n     * @author tlwr [toby@toby.codes]\n     * @author n1474335 [n1474335@gmail.com]\n     *\n     * @param {File[]} files\n     * @returns {html}\n     */\n    static async displayFilesAsHTML(files) {\n        const formatDirectory = function(file) {\n            const html = `<div class='card' style='white-space: normal;'>\n                    <div class='card-header'>\n                        <h6 class=\"mb-0\">\n                            ${Utils.escapeHtml(file.name)}\n                        </h6>\n                    </div>\n                </div>`;\n            return html;\n        };\n\n        const formatContent = function (buff, type) {\n            if (type.startsWith(\"image\")) {\n                let dataURI = \"data:\";\n                dataURI += type + \";\";\n                dataURI += \"base64,\" + (0,_lib_Base64_mjs__WEBPACK_IMPORTED_MODULE_2__.toBase64)(buff);\n                return \"<img style='max-width: 100%;' src='\" + dataURI + \"'>\";\n            } else {\n                return `<pre>${Utils.escapeHtml(Utils.arrayBufferToStr(buff.buffer))}</pre>`;\n            }\n        };\n\n        const formatFile = async function(file, i) {\n            const buff = await Utils.readFile(file);\n            const blob = new Blob(\n                [buff],\n                {type: file.type || \"octet/stream\"}\n            );\n            const blobURL = URL.createObjectURL(blob);\n\n            const html = `<div class='card' style='white-space: normal;'>\n                    <div class='card-header' id='heading${i}'>\n                        <h6 class='mb-0'>\n                            <a class='collapsed'\n                                data-toggle='collapse'\n                                href='#collapse${i}'\n                                aria-expanded='false'\n                                aria-controls='collapse${i}'\n                                title=\"Show/hide contents of '${Utils.escapeHtml(file.name)}'\">\n                                ${Utils.escapeHtml(file.name)}</a>\n                            <span class='float-right' style=\"margin-top: -3px\">\n                                ${file.size.toLocaleString()} bytes\n                                <a title=\"Download ${Utils.escapeHtml(file.name)}\"\n                                    href=\"${blobURL}\"\n                                    download=\"${Utils.escapeHtml(file.name)}\"\n                                    data-toggle=\"tooltip\">\n                                    <i class=\"material-icons\" style=\"vertical-align: bottom\">save</i>\n                                </a>\n                                <a title=\"Move to input\"\n                                    href=\"#\"\n                                    blob-url=\"${blobURL}\"\n                                    file-name=\"${Utils.escapeHtml(file.name)}\"\n                                    class=\"extract-file\"\n                                    data-toggle=\"tooltip\">\n                                    <i class=\"material-icons\" style=\"vertical-align: bottom\">open_in_browser</i>\n                                </a>\n                            </span>\n                        </h6>\n                    </div>\n                    <div id='collapse${i}' class='collapse' aria-labelledby='heading${i}' data-parent=\"#files\">\n                        <div class='card-body'>\n                            ${formatContent(buff, file.type)}\n                        </div>\n                    </div>\n                </div>`;\n            return html;\n        };\n\n        let html = `<div style='padding: 5px; white-space: normal;'>\n                ${files.length} file(s) found\n            </div><div id=\"files\" style=\"padding: 20px\">`;\n\n        for (let i = 0; i < files.length; i++) {\n            if (files[i].name.endsWith(\"/\")) {\n                html += formatDirectory(files[i]);\n            } else {\n                html += await formatFile(files[i], i);\n            }\n        }\n\n        return html += \"</div>\";\n    }\n\n\n    /**\n     * Parses URI parameters into a JSON object.\n     *\n     * @param {string} paramStr - The serialised query or hash section of a URI\n     * @returns {object}\n     *\n     * @example\n     * // returns {a: 'abc', b: '123'}\n     * Utils.parseURIParams(\"?a=abc&b=123\")\n     * Utils.parseURIParams(\"#a=abc&b=123\")\n     */\n    static parseURIParams(paramStr) {\n        if (paramStr === \"\") return {};\n\n        // Cut off ? or # and split on &\n        if (paramStr[0] === \"?\" ||\n            paramStr[0] === \"#\") {\n            paramStr = paramStr.substr(1);\n        }\n\n        const params = paramStr.split(\"&\");\n        const result = {};\n\n        for (let i = 0; i < params.length; i++) {\n            const param = params[i].split(\"=\");\n            if (param.length !== 2) {\n                result[params[i]] = true;\n            } else {\n                result[param[0]] = decodeURIComponent(param[1].replace(/\\+/g, \" \"));\n            }\n        }\n\n        return result;\n    }\n\n\n    /**\n     * Reads a File and returns the data as a Uint8Array.\n     *\n     * @param {File | for node: array|arrayBuffer|buffer|string} file\n     * @returns {Uint8Array}\n     *\n     * @example\n     * // returns Uint8Array(5) [104, 101, 108, 108, 111]\n     * await Utils.readFile(new File([\"hello\"], \"test\"))\n     */\n    static readFile(file) {\n\n        if (isNodeEnvironment()) {\n            return Buffer.from(file).buffer;\n\n        } else {\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                const data = new Uint8Array(file.size);\n                let offset = 0;\n                const CHUNK_SIZE = 10485760; // 10MiB\n\n                const seek = function() {\n                    if (offset >= file.size) {\n                        resolve(data);\n                        return;\n                    }\n                    const slice = file.slice(offset, offset + CHUNK_SIZE);\n                    reader.readAsArrayBuffer(slice);\n                };\n\n                reader.onload = function(e) {\n                    data.set(new Uint8Array(reader.result), offset);\n                    offset += CHUNK_SIZE;\n                    seek();\n                };\n\n                reader.onerror = function(e) {\n                    reject(reader.error.message);\n                };\n\n                seek();\n            });\n        }\n    }\n\n    /**\n     * Synchronously read the raw data from a File object.\n     *\n     * Only works in the Node environment\n     *\n     * @param {File} file - a File shim object (see src/node/File.mjs)\n     * @returns {ArrayBuffer} the data from the file in an ArrayBuffer\n     * @throws {TypeError} thrown if the method is called from a browser environment\n     */\n    static readFileSync(file) {\n        if (!isNodeEnvironment()) {\n            throw new TypeError(\"Browser environment cannot support readFileSync\");\n        }\n\n        const arrayBuffer = Uint8Array.from(file.data);\n        return arrayBuffer.buffer;\n    }\n\n\n    /**\n     * Actual modulo function, since % is actually the remainder function in JS.\n     *\n     * @author Matt C [matt@artemisbot.uk]\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static mod(x, y) {\n        return ((x % y) + y) % y;\n    }\n\n\n    /**\n     * Finds the greatest common divisor of two numbers.\n     *\n     * @author Matt C [matt@artemisbot.uk]\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static gcd(x, y) {\n        if (!y) {\n            return x;\n        }\n        return Utils.gcd(y, x % y);\n    }\n\n\n    /**\n     * Finds the modular inverse of two values.\n     *\n     * @author Matt C [matt@artemisbot.uk]\n     * @param {number} x\n     * @param {number} y\n     * @returns {number}\n     */\n    static modInv(x, y) {\n        x %= y;\n        for (let i = 1; i < y; i++) {\n            if ((x * i) % 26 === 1) {\n                return i;\n            }\n        }\n    }\n\n\n    /**\n     * A mapping of names of delimiter characters to their symbols.\n     *\n     * @param {string} token\n     * @returns {string}\n     */\n    static charRep(token) {\n        return {\n            \"Space\":         \" \",\n            \"Percent\":       \"%\",\n            \"Comma\":         \",\",\n            \"Semi-colon\":    \";\",\n            \"Colon\":         \":\",\n            \"Tab\":           \"\\t\",\n            \"Line feed\":     \"\\n\",\n            \"CRLF\":          \"\\r\\n\",\n            \"Forward slash\": \"/\",\n            \"Backslash\":     \"\\\\\",\n            \"0x\":            \"0x\",\n            \"\\\\x\":           \"\\\\x\",\n            \"Nothing (separate chars)\": \"\",\n            \"None\":          \"\",\n        }[token];\n    }\n\n\n    /**\n     * A mapping of names of delimiter characters to regular expressions which can select them.\n     *\n     * @param {string} token\n     * @returns {RegExp}\n     */\n    static regexRep(token) {\n        return {\n            \"Space\":         /\\s+/g,\n            \"Percent\":       /%/g,\n            \"Comma\":         /,/g,\n            \"Semi-colon\":    /;/g,\n            \"Colon\":         /:/g,\n            \"Line feed\":     /\\n/g,\n            \"CRLF\":          /\\r\\n/g,\n            \"Forward slash\": /\\//g,\n            \"Backslash\":     /\\\\/g,\n            \"0x with comma\": /,?0x/g,\n            \"0x\":            /0x/g,\n            \"\\\\x\":           /\\\\x/g,\n            \"None\":          /\\s+/g // Included here to remove whitespace when there shouldn't be any\n        }[token];\n    }\n\n    /**\n     * Iterate object in chunks of given size.\n     *\n     * @param {Iterable} iterable\n     * @param {number} chunksize\n     */\n    static* chunked(iterable, chunksize) {\n        const iterator = iterable[Symbol.iterator]();\n        while (true) {\n            const res = [];\n            for (let i = 0; i < chunksize; i++) {\n                const next = iterator.next();\n                if (next.done) {\n                    break;\n                }\n                res.push(next.value);\n            }\n            if (res.length) {\n                yield res;\n            } else {\n                return;\n            }\n        }\n    }\n}\n\n/**\n * Check whether the code is running in a Node.js environment\n * @returns {boolean}\n */\nfunction isNodeEnvironment() {\n    return typeof process !== \"undefined\" && process.versions != null && process.versions.node != null;\n}\n\n/**\n * Check whether the code is running in a web environment\n * @returns {boolean}\n*/\nfunction isWebEnvironment() {\n    return typeof window === \"object\";\n}\n\n/**\n * Check whether the code is running in a worker\n * @returns {boolean}\n*/\nfunction isWorkerEnvironment() {\n    return typeof importScripts === \"function\";\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Utils);\n\n\n/**\n * Removes all duplicates from an array.\n *\n * @returns {Array}\n *\n * @example\n * // returns [3,6,4,8,2]\n * [3,6,4,8,4,2,3].unique();\n *\n * // returns [\"One\", \"Two\", \"Three\"]\n * [\"One\", \"Two\", \"Three\", \"One\"].unique();\n */\nArray.prototype.unique = function() {\n    const u = {}, a = [];\n    for (let i = 0, l = this.length; i < l; i++) {\n        if (Object.prototype.hasOwnProperty.call(u, this[i])) {\n            continue;\n        }\n        a.push(this[i]);\n        u[this[i]] = 1;\n    }\n    return a;\n};\n\n\n/**\n * Returns the largest value in the array.\n *\n * @returns {number}\n *\n * @example\n * // returns 7\n * [4,2,5,3,7].max();\n */\nArray.prototype.max = function() {\n    return Math.max.apply(null, this);\n};\n\n\n/**\n * Returns the smallest value in the array.\n *\n * @returns {number}\n *\n * @example\n * // returns 2\n * [4,2,5,3,7].min();\n */\nArray.prototype.min = function() {\n    return Math.min.apply(null, this);\n};\n\n\n/**\n * Sums all the values in an array.\n *\n * @returns {number}\n *\n * @example\n * // returns 21\n * [4,2,5,3,7].sum();\n */\nArray.prototype.sum = function() {\n    return this.reduce(function (a, b) {\n        return a + b;\n    }, 0);\n};\n\n\n/**\n * Determine whether two arrays are equal or not.\n *\n * @param {Object[]} other\n * @returns {boolean}\n *\n * @example\n * // returns true\n * [1,2,3].equals([1,2,3]);\n *\n * // returns false\n * [1,2,3].equals([3,2,1]);\n */\nArray.prototype.equals = function(other) {\n    if (!other) return false;\n    let i = this.length;\n    if (i !== other.length) return false;\n    while (i--) {\n        if (this[i] !== other[i]) return false;\n    }\n    return true;\n};\n\n\n/**\n * Counts the number of times a char appears in a string.\n *\n * @param {char} chr\n * @returns {number}\n *\n * @example\n * // returns 2\n * \"Hello\".count(\"l\");\n */\nString.prototype.count = function(chr) {\n    return this.split(chr).length - 1;\n};\n\n\n/**\n * Wrapper for self.sendStatusMessage to handle different environments.\n *\n * @param {string} msg\n */\nfunction sendStatusMessage(msg) {\n    if (isWorkerEnvironment())\n        self.sendStatusMessage(msg);\n    else if (isWebEnvironment())\n        app.alert(msg, 10000);\n    else if (isNodeEnvironment() && !global.TESTING)\n        // eslint-disable-next-line no-console\n        console.debug(msg);\n}\n\nconst debounceTimeouts = {};\n\n/**\n * Debouncer to stop functions from being executed multiple times in a\n * short space of time\n * https://davidwalsh.name/javascript-debounce-function\n *\n * @param {function} func - The function to be executed after the debounce time\n * @param {number} wait - The time (ms) to wait before executing the function\n * @param {string} id - Unique ID to reference the timeout for the function\n * @param {object} scope - The object to bind to the debounced function\n * @param {array} args - Array of arguments to be passed to func\n * @returns {function}\n */\nfunction debounce(func, wait, id, scope, args) {\n    return function() {\n        const later = function() {\n            func.apply(scope, args);\n        };\n        clearTimeout(debounceTimeouts[id]);\n        debounceTimeouts[id] = setTimeout(later, wait);\n    };\n}\n\n\n/*\n * Polyfills\n */\n\n// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart\nif (!String.prototype.padStart) {\n    String.prototype.padStart = function padStart(targetLength, padString) {\n        targetLength = targetLength>>0; // floor if number or convert non-number to 0;\n        padString = String((typeof padString !== \"undefined\" ? padString : \" \"));\n        if (this.length > targetLength) {\n            return String(this);\n        } else {\n            targetLength = targetLength-this.length;\n            if (targetLength > padString.length) {\n                padString += padString.repeat(targetLength/padString.length); // append to original to ensure we are longer than needed\n            }\n            return padString.slice(0, targetLength) + String(this);\n        }\n    };\n}\n\n\n// https://github.com/uxitten/polyfill/blob/master/string.polyfill.js\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd\nif (!String.prototype.padEnd) {\n    String.prototype.padEnd = function padEnd(targetLength, padString) {\n        targetLength = targetLength>>0; // floor if number or convert non-number to 0;\n        padString = String((typeof padString !== \"undefined\" ? padString : \" \"));\n        if (this.length > targetLength) {\n            return String(this);\n        } else {\n            targetLength = targetLength-this.length;\n            if (targetLength > padString.length) {\n                padString += padString.repeat(targetLength/padString.length); // append to original to ensure we are longer than needed\n            }\n            return String(this) + padString.slice(0, targetLength);\n        }\n    };\n}\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/Utils.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/errors/OperationError.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/cyberchef/src/core/errors/OperationError.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Custom error type for handling operation input errors.\n * i.e. where the operation can handle the error and print a message to the screen.\n *\n * @author d98762625 [d98762625@gmail.com]\n * @copyright Crown Copyright 2018\n * @license Apache-2.0\n */\nclass OperationError extends Error {\n    /**\n     * Standard error constructor. Adds no new behaviour.\n     *\n     * @param args - Standard error args\n     */\n    constructor(...args) {\n        super(...args);\n\n        this.type = \"OperationError\";\n\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, OperationError);\n        }\n    }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OperationError);\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/errors/OperationError.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/Base64.mjs":
/*!********************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/Base64.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ALPHABET_OPTIONS: () => (/* binding */ ALPHABET_OPTIONS),\n/* harmony export */   fromBase64: () => (/* binding */ fromBase64),\n/* harmony export */   toBase64: () => (/* binding */ toBase64)\n/* harmony export */ });\n/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils.mjs */ \"./node_modules/cyberchef/src/core/Utils.mjs\");\n/* harmony import */ var _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/OperationError.mjs */ \"./node_modules/cyberchef/src/core/errors/OperationError.mjs\");\n/**\n * Base64 functions.\n *\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2016\n * @license Apache-2.0\n */\n\n\n\n\n/**\n * Base64's the input byte array using the given alphabet, returning a string.\n *\n * @param {byteArray|Uint8Array|ArrayBuffer|string} data\n * @param {string} [alphabet=\"A-Za-z0-9+/=\"]\n * @returns {string}\n *\n * @example\n * // returns \"SGVsbG8=\"\n * toBase64([72, 101, 108, 108, 111]);\n *\n * // returns \"SGVsbG8=\"\n * toBase64(\"Hello\");\n */\nfunction toBase64(data, alphabet=\"A-Za-z0-9+/=\") {\n    if (!data) return \"\";\n    if (typeof data == \"string\") {\n        data = _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].strToArrayBuffer(data);\n    }\n    if (data instanceof ArrayBuffer) {\n        data = new Uint8Array(data);\n    }\n\n    alphabet = _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].expandAlphRange(alphabet).join(\"\");\n    if (alphabet.length !== 64 && alphabet.length !== 65) { // Allow for padding\n        throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](`Invalid Base64 alphabet length (${alphabet.length}): ${alphabet}`);\n    }\n\n    let output = \"\",\n        chr1, chr2, chr3,\n        enc1, enc2, enc3, enc4,\n        i = 0;\n\n    while (i < data.length) {\n        chr1 = data[i++];\n        chr2 = data[i++];\n        chr3 = data[i++];\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n            enc3 = enc4 = 64;\n        } else if (isNaN(chr3)) {\n            enc4 = 64;\n        }\n\n        output += alphabet.charAt(enc1) + alphabet.charAt(enc2) +\n            alphabet.charAt(enc3) + alphabet.charAt(enc4);\n    }\n\n    return output;\n}\n\n\n/**\n * UnBase64's the input string using the given alphabet, returning a byte array.\n *\n * @param {string} data\n * @param {string} [alphabet=\"A-Za-z0-9+/=\"]\n * @param {string} [returnType=\"string\"] - Either \"string\" or \"byteArray\"\n * @param {boolean} [removeNonAlphChars=true]\n * @returns {byteArray}\n *\n * @example\n * // returns \"Hello\"\n * fromBase64(\"SGVsbG8=\");\n *\n * // returns [72, 101, 108, 108, 111]\n * fromBase64(\"SGVsbG8=\", null, \"byteArray\");\n */\nfunction fromBase64(data, alphabet=\"A-Za-z0-9+/=\", returnType=\"string\", removeNonAlphChars=true, strictMode=false) {\n    if (!data) {\n        return returnType === \"string\" ? \"\" : [];\n    }\n\n    alphabet = alphabet || \"A-Za-z0-9+/=\";\n    alphabet = _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].expandAlphRange(alphabet).join(\"\");\n\n    // Confirm alphabet is a valid length\n    if (alphabet.length !== 64 && alphabet.length !== 65) { // Allow for padding\n        throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](`Error: Base64 alphabet should be 64 characters long, or 65 with a padding character. Found ${alphabet.length}: ${alphabet}`);\n    }\n\n    // Remove non-alphabet characters\n    if (removeNonAlphChars) {\n        const re = new RegExp(\"[^\" + alphabet.replace(/[[\\]\\\\\\-^$]/g, \"\\\\$&\") + \"]\", \"g\");\n        data = data.replace(re, \"\");\n    }\n\n    if (strictMode) {\n        // Check for incorrect lengths (even without padding)\n        if (data.length % 4 === 1) {\n            throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](`Error: Invalid Base64 input length (${data.length}). Cannot be 4n+1, even without padding chars.`);\n        }\n\n        if (alphabet.length === 65) { // Padding character included\n            const pad = alphabet.charAt(64);\n            const padPos = data.indexOf(pad);\n            if (padPos >= 0) {\n                // Check that the padding character is only used at the end and maximum of twice\n                if (padPos < data.length - 2 || data.charAt(data.length - 1) !== pad) {\n                    throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](`Error: Base64 padding character (${pad}) not used in the correct place.`);\n                }\n\n                // Check that input is padded to the correct length\n                if (data.length % 4 !== 0) {\n                    throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Error: Base64 not padded to a multiple of 4.\");\n                }\n            }\n        }\n    }\n\n    const output = [];\n    let chr1, chr2, chr3,\n        enc1, enc2, enc3, enc4,\n        i = 0;\n\n    while (i < data.length) {\n        // Including `|| null` forces empty strings to null so that indexOf returns -1 instead of 0\n        enc1 = alphabet.indexOf(data.charAt(i++) || null);\n        enc2 = alphabet.indexOf(data.charAt(i++) || null);\n        enc3 = alphabet.indexOf(data.charAt(i++) || null);\n        enc4 = alphabet.indexOf(data.charAt(i++) || null);\n\n        if (strictMode && (enc1 < 0 || enc2 < 0 || enc3 < 0 || enc4 < 0)) {\n            throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Error: Base64 input contains non-alphabet char(s)\");\n        }\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        if (chr1 >= 0 && chr1 < 256) {\n            output.push(chr1);\n        }\n        if (chr2 >= 0 && chr2 < 256 && enc3 !== 64) {\n            output.push(chr2);\n        }\n        if (chr3 >= 0 && chr3 < 256 && enc4 !== 64) {\n            output.push(chr3);\n        }\n    }\n\n    return returnType === \"string\" ? _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].byteArrayToUtf8(output) : output;\n}\n\n\n/**\n * Base64 alphabets.\n */\nconst ALPHABET_OPTIONS = [\n    {name: \"Standard (RFC 4648): A-Za-z0-9+/=\", value: \"A-Za-z0-9+/=\"},\n    {name: \"URL safe (RFC 4648 \\u00A75): A-Za-z0-9-_\", value: \"A-Za-z0-9-_\"},\n    {name: \"Filename safe: A-Za-z0-9+-=\", value: \"A-Za-z0-9+\\\\-=\"},\n    {name: \"itoa64: ./0-9A-Za-z=\", value: \"./0-9A-Za-z=\"},\n    {name: \"XML: A-Za-z0-9_.\", value: \"A-Za-z0-9_.\"},\n    {name: \"y64: A-Za-z0-9._-\", value: \"A-Za-z0-9._-\"},\n    {name: \"z64: 0-9a-zA-Z+/=\", value: \"0-9a-zA-Z+/=\"},\n    {name: \"Radix-64 (RFC 4880): 0-9A-Za-z+/=\", value: \"0-9A-Za-z+/=\"},\n    {name: \"Uuencoding: [space]-_\", value: \" -_\"},\n    {name: \"Xxencoding: +-0-9A-Za-z\", value: \"+\\\\-0-9A-Za-z\"},\n    {name: \"BinHex: !-,-0-689@A-NP-VX-Z[`a-fh-mp-r\", value: \"!-,-0-689@A-NP-VX-Z[`a-fh-mp-r\"},\n    {name: \"ROT13: N-ZA-Mn-za-m0-9+/=\", value: \"N-ZA-Mn-za-m0-9+/=\"},\n    {name: \"UNIX crypt: ./0-9A-Za-z\", value: \"./0-9A-Za-z\"},\n    {name: \"Atom128: /128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC\", value: \"/128GhIoPQROSTeUbADfgHijKLM+n0pFWXY456xyzB7=39VaqrstJklmNuZvwcdEC\"},\n    {name: \"Megan35: 3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5\", value: \"3GHIJKLMNOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5\"},\n    {name: \"Zong22: ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2\", value: \"ZKj9n+yf0wDVX1s/5YbdxSo=ILaUpPBCHg8uvNO4klm6iJGhQ7eFrWczAMEq3RTt2\"},\n    {name: \"Hazz15: HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5\", value: \"HNO4klm6ij9n+J2hyf0gzA8uvwDEq3X1Q7ZKeFrWcVTts/MRGYbdxSo=ILaUpPBC5\"}\n];\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/Base64.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/Binary.mjs":
/*!********************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/Binary.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromBinary: () => (/* binding */ fromBinary),\n/* harmony export */   toBinary: () => (/* binding */ toBinary)\n/* harmony export */ });\n/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils.mjs */ \"./node_modules/cyberchef/src/core/Utils.mjs\");\n/* harmony import */ var _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/OperationError.mjs */ \"./node_modules/cyberchef/src/core/errors/OperationError.mjs\");\n/**\n * Binary functions.\n *\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2018\n * @license Apache-2.0\n */\n\n\n\n\n\n/**\n * Convert a byte array into a binary string.\n *\n * @param {Uint8Array|byteArray|number} data\n * @param {string} [delim=\"Space\"]\n * @param {number} [padding=8]\n * @returns {string}\n *\n * @example\n * // returns \"00001010 00010100 00011110\"\n * toBinary([10,20,30]);\n *\n * // returns \"00001010:00010100:00011110\"\n * toBinary([10,20,30], \"Colon\");\n *\n * // returns \"1010:10100:11110\"\n * toBinary([10,20,30], \"Colon\", 0);\n */\nfunction toBinary(data, delim=\"Space\", padding=8) {\n    if (data === undefined || data === null)\n        throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Unable to convert to binary: Empty input data enocuntered\");\n\n    delim = _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charRep(delim);\n    let output = \"\";\n\n    if (data.length) { // array\n        for (let i = 0; i < data.length; i++) {\n            output += data[i].toString(2).padStart(padding, \"0\");\n            if (i !== data.length - 1) output += delim;\n        }\n    } else if (typeof data === \"number\") { // Single value\n        return data.toString(2).padStart(padding, \"0\");\n    } else {\n        return \"\";\n    }\n    return output;\n}\n\n\n/**\n * Convert a binary string into a byte array.\n *\n * @param {string} data\n * @param {string} [delim]\n * @param {number} [byteLen=8]\n * @returns {byteArray}\n *\n * @example\n * // returns [10,20,30]\n * fromBinary(\"00001010 00010100 00011110\");\n *\n * // returns [10,20,30]\n * fromBinary(\"00001010:00010100:00011110\", \"Colon\");\n */\nfunction fromBinary(data, delim=\"Space\", byteLen=8) {\n    if (byteLen < 1 || Math.round(byteLen) !== byteLen)\n        throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Byte length must be a positive integer\");\n\n    const delimRegex = _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regexRep(delim);\n    data = data.replace(delimRegex, \"\");\n\n    const output = [];\n    for (let i = 0; i < data.length; i += byteLen) {\n        output.push(parseInt(data.substr(i, byteLen), 2));\n    }\n    return output;\n}\n\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/Binary.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/Decimal.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/Decimal.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromDecimal: () => (/* binding */ fromDecimal)\n/* harmony export */ });\n/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils.mjs */ \"./node_modules/cyberchef/src/core/Utils.mjs\");\n/**\n * Decimal functions.\n *\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2018\n * @license Apache-2.0\n */\n\n\n\n\n/**\n * Convert a string of decimal values into a byte array.\n *\n * @param {string} data\n * @param {string} [delim]\n * @returns {byteArray}\n *\n * @example\n * // returns [10,20,30]\n * fromDecimal(\"10 20 30\");\n *\n * // returns [10,20,30]\n * fromDecimal(\"10:20:30\", \"Colon\");\n */\nfunction fromDecimal(data, delim=\"Auto\") {\n    delim = _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].charRep(delim);\n    const output = [];\n    let byteStr = data.split(delim);\n    if (byteStr[byteStr.length-1] === \"\")\n        byteStr = byteStr.slice(0, byteStr.length-1);\n\n    for (let i = 0; i < byteStr.length; i++) {\n        output[i] = parseInt(byteStr[i], 10);\n    }\n    return output;\n}\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/Decimal.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/FileSignatures.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/FileSignatures.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FILE_SIGNATURES: () => (/* binding */ FILE_SIGNATURES),\n/* harmony export */   extractBMP: () => (/* binding */ extractBMP),\n/* harmony export */   extractBZIP2: () => (/* binding */ extractBZIP2),\n/* harmony export */   extractDEB: () => (/* binding */ extractDEB),\n/* harmony export */   extractDMP: () => (/* binding */ extractDMP),\n/* harmony export */   extractELF: () => (/* binding */ extractELF),\n/* harmony export */   extractEVT: () => (/* binding */ extractEVT),\n/* harmony export */   extractEVTX: () => (/* binding */ extractEVTX),\n/* harmony export */   extractFLV: () => (/* binding */ extractFLV),\n/* harmony export */   extractGIF: () => (/* binding */ extractGIF),\n/* harmony export */   extractGZIP: () => (/* binding */ extractGZIP),\n/* harmony export */   extractICO: () => (/* binding */ extractICO),\n/* harmony export */   extractJPEG: () => (/* binding */ extractJPEG),\n/* harmony export */   extractLNK: () => (/* binding */ extractLNK),\n/* harmony export */   extractLZOP: () => (/* binding */ extractLZOP),\n/* harmony export */   extractMACHO: () => (/* binding */ extractMACHO),\n/* harmony export */   extractMP3: () => (/* binding */ extractMP3),\n/* harmony export */   extractMZPE: () => (/* binding */ extractMZPE),\n/* harmony export */   extractMacOSXKeychain: () => (/* binding */ extractMacOSXKeychain),\n/* harmony export */   extractOLE2: () => (/* binding */ extractOLE2),\n/* harmony export */   extractPDF: () => (/* binding */ extractPDF),\n/* harmony export */   extractPF: () => (/* binding */ extractPF),\n/* harmony export */   extractPFWin10: () => (/* binding */ extractPFWin10),\n/* harmony export */   extractPListXML: () => (/* binding */ extractPListXML),\n/* harmony export */   extractPNG: () => (/* binding */ extractPNG),\n/* harmony export */   extractRTF: () => (/* binding */ extractRTF),\n/* harmony export */   extractSQLITE: () => (/* binding */ extractSQLITE),\n/* harmony export */   extractTAR: () => (/* binding */ extractTAR),\n/* harmony export */   extractTARGA: () => (/* binding */ extractTARGA),\n/* harmony export */   extractWAV: () => (/* binding */ extractWAV),\n/* harmony export */   extractWEBP: () => (/* binding */ extractWEBP),\n/* harmony export */   extractXZ: () => (/* binding */ extractXZ),\n/* harmony export */   extractZIP: () => (/* binding */ extractZIP),\n/* harmony export */   extractZlib: () => (/* binding */ extractZlib)\n/* harmony export */ });\n/* harmony import */ var _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Stream.mjs */ \"./node_modules/cyberchef/src/core/lib/Stream.mjs\");\n/**\n * File signatures and extractor functions\n *\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2018\n * @license Apache-2.0\n *\n */\n\n\n/**\n * A categorised table of file types, including signatures to identify them and functions\n * to extract them where possible.\n */\nconst FILE_SIGNATURES = {\n    \"Images\": [\n        {\n            name: \"Joint Photographic Experts Group image\",\n            extension: \"jpg,jpeg,jpe,thm,mpo\",\n            mime: \"image/jpeg\",\n            description: \"\",\n            signature: {\n                0: 0xff,\n                1: 0xd8,\n                2: 0xff,\n                3: [0xc0, 0xc4, 0xdb, 0xdd, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe7, 0xe8, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xfe]\n            },\n            extractor: extractJPEG\n        },\n        {\n            name: \"Graphics Interchange Format image\",\n            extension: \"gif\",\n            mime: \"image/gif\",\n            description: \"\",\n            signature: {\n                0: 0x47, // GIF\n                1: 0x49,\n                2: 0x46,\n                3: 0x38, // 8\n                4: [0x37, 0x39], // 7|9\n                5: 0x61  // a\n            },\n            extractor: extractGIF\n        },\n        {\n            name: \"Portable Network Graphics image\",\n            extension: \"png\",\n            mime: \"image/png\",\n            description: \"\",\n            signature: {\n                0: 0x89,\n                1: 0x50, // PNG\n                2: 0x4e,\n                3: 0x47,\n                4: 0x0d,\n                5: 0x0a,\n                6: 0x1a,\n                7: 0x0a\n            },\n            extractor: extractPNG\n        },\n        {\n            name: \"WEBP Image\",\n            extension: \"webp\",\n            mime: \"image/webp\",\n            description: \"\",\n            signature: {\n                8: 0x57,\n                9: 0x45,\n                10: 0x42,\n                11: 0x50\n            },\n            extractor: extractWEBP\n        },\n        {\n            name: \"High Efficiency Image File Format\",\n            extension: \"heic,heif\",\n            mime: \"image/heif\",\n            description: \"\",\n            signature: {\n                0: 0x00,\n                1: 0x00,\n                2: 0x00,\n                3: [0x24, 0x18],\n                4: 0x66, // ftypheic\n                5: 0x74,\n                6: 0x79,\n                7: 0x70,\n                8: 0x68,\n                9: 0x65,\n                10: 0x69,\n                11: 0x63\n            },\n            extractor: null\n        },\n        {\n            name: \"Camera Image File Format\",\n            extension: \"crw\",\n            mime: \"image/x-canon-crw\",\n            description: \"\",\n            signature: {\n                6: 0x48, // HEAPCCDR\n                7: 0x45,\n                8: 0x41,\n                9: 0x50,\n                10: 0x43,\n                11: 0x43,\n                12: 0x44,\n                13: 0x52\n            },\n            extractor: null\n        },\n        { // Place before tiff check\n            name: \"Canon CR2 raw image\",\n            extension: \"cr2\",\n            mime: \"image/x-canon-cr2\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x49,\n                    1: 0x49,\n                    2: 0x2a,\n                    3: 0x0,\n                    8: 0x43,\n                    9: 0x52\n                },\n                {\n                    0: 0x4d,\n                    1: 0x4d,\n                    2: 0x0,\n                    3: 0x2a,\n                    8: 0x43,\n                    9: 0x52\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"Tagged Image File Format image\",\n            extension: \"tif\",\n            mime: \"image/tiff\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x49,\n                    1: 0x49,\n                    2: 0x2a,\n                    3: 0x0\n                },\n                {\n                    0: 0x4d,\n                    1: 0x4d,\n                    2: 0x0,\n                    3: 0x2a\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"Bitmap image\",\n            extension: \"bmp\",\n            mime: \"image/bmp\",\n            description: \"\",\n            signature: {\n                0: 0x42,\n                1: 0x4d,\n                7: 0x0,\n                9: 0x0,\n                14: [0x0c, 0x28, 0x38, 0x40, 0x6c, 0x7c],\n                15: 0x0,\n                16: 0x0,\n                17: 0x0\n            },\n            extractor: extractBMP\n        },\n        {\n            name: \"JPEG Extended Range image\",\n            extension: \"jxr\",\n            mime: \"image/vnd.ms-photo\",\n            description: \"\",\n            signature: {\n                0: 0x49,\n                1: 0x49,\n                2: 0xbc\n            },\n            extractor: null\n        },\n        {\n            name: \"Photoshop image\",\n            extension: \"psd\",\n            mime: \"image/vnd.adobe.photoshop\",\n            description: \"\",\n            signature: {\n                0: 0x38, // 8BPS\n                1: 0x42,\n                2: 0x50,\n                3: 0x53,\n                4: 0x0,\n                5: 0x1,\n                6: 0x0,\n                7: 0x0,\n                8: 0x0,\n                9: 0x0,\n                10: 0x0,\n                11: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"Photoshop Large Document\",\n            extension: \"psb\",\n            mime: \"application/x-photoshop\",\n            description: \"\",\n            signature: {\n                0: 0x38, // 8BPS\n                1: 0x42,\n                2: 0x50,\n                3: 0x53,\n                4: 0x0,\n                5: 0x2,\n                6: 0x0,\n                7: 0x0,\n                8: 0x0,\n                9: 0x0,\n                10: 0x0,\n                11: 0x0,\n                12: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"Paint Shop Pro image\",\n            extension: \"psp\",\n            mime: \"image/psp\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x50, // Paint Shop Pro Im\n                    1: 0x61,\n                    2: 0x69,\n                    3: 0x6e,\n                    4: 0x74,\n                    5: 0x20,\n                    6: 0x53,\n                    7: 0x68,\n                    8: 0x6f,\n                    9: 0x70,\n                    10: 0x20,\n                    11: 0x50,\n                    12: 0x72,\n                    13: 0x6f,\n                    14: 0x20,\n                    15: 0x49,\n                    16: 0x6d\n                },\n                {\n                    0: 0x7e,\n                    1: 0x42,\n                    2: 0x4b,\n                    3: 0x0\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"The GIMP image\",\n            extension: \"xcf\",\n            mime: \"image/x-xcf\",\n            description: \"\",\n            signature: {\n                0: 0x67, // gimp xcf\n                1: 0x69,\n                2: 0x6d,\n                3: 0x70,\n                4: 0x20,\n                5: 0x78,\n                6: 0x63,\n                7: 0x66,\n                8: 0x20,\n                9: [0x66, 0x76],\n                10: [0x69, 0x30],\n                11: [0x6c, 0x30],\n                12: [0x65, 0x31, 0x32, 0x33]\n            },\n            extractor: null\n        },\n        {\n            name: \"Icon image\",\n            extension: \"ico\",\n            mime: \"image/x-icon\",\n            description: \"\",\n            signature: {\n                0: 0x0,\n                1: 0x0,\n                2: 0x1,\n                3: 0x0,\n                4: [0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15],\n                5: 0x0,\n                6: [0x10, 0x20, 0x30, 0x40, 0x80],\n                7: [0x10, 0x20, 0x30, 0x40, 0x80],\n                9: 0x0,\n                10: [0x0, 0x1]\n            },\n            extractor: extractICO\n        },\n        {\n            name: \"Radiance High Dynamic Range image\",\n            extension: \"hdr\",\n            mime: \"image/vnd.radiance\",\n            description: \"\",\n            signature: {\n                0: 0x23, // #?RADIANCE\n                1: 0x3f,\n                2: 0x52,\n                3: 0x41,\n                4: 0x44,\n                5: 0x49,\n                6: 0x41,\n                7: 0x4e,\n                8: 0x43,\n                9: 0x45,\n                10: 0x0a\n            },\n            extractor: null\n        },\n        {\n            name: \"Sony ARW image\",\n            extension: \"arw\",\n            mime: \"image/x-raw\",\n            description: \"\",\n            signature: {\n                0: 0x05,\n                1: 0x0,\n                2: 0x0,\n                3: 0x0,\n                4: 0x41,\n                5: 0x57,\n                6: 0x31,\n                7: 0x2e\n            },\n            extractor: null\n        },\n        {\n            name: \"Fujifilm Raw Image\",\n            extension: \"raf\",\n            mime: \"image/x-raw\",\n            description: \"\",\n            signature: {\n                0: 0x46, // FUJIFILMCCD-RAW\n                1: 0x55,\n                2: 0x4a,\n                3: 0x49,\n                4: 0x46,\n                5: 0x49,\n                6: 0x4c,\n                7: 0x4d,\n                8: 0x43,\n                9: 0x43,\n                10: 0x44,\n                11: 0x2d,\n                12: 0x52,\n                13: 0x41,\n                14: 0x57\n            },\n            extractor: null\n        },\n        {\n            name: \"Minolta RAW image\",\n            extension: \"mrw\",\n            mime: \"image/x-raw\",\n            description: \"\",\n            signature: {\n                0: 0x0,\n                1: 0x4d, // MRM\n                2: 0x52,\n                3: 0x4d\n            },\n            extractor: null\n        },\n        {\n            name: \"Adobe Bridge Thumbnail Cache\",\n            extension: \"bct\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x6c,\n                1: 0x6e,\n                2: 0x62,\n                3: 0x74,\n                4: 0x02,\n                5: 0x0,\n                6: 0x0,\n                7: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft Document Imaging\",\n            extension: \"mdi\",\n            mime: \"image/vnd.ms-modi\",\n            description: \"\",\n            signature: {\n                0: 0x45,\n                1: 0x50,\n                2: 0x2a,\n                3: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Joint Photographic Experts Group image (under Base64)\",\n            extension: \"B64\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x2f,\n                1: 0x39,\n                2: 0x6a,\n                3: 0x2f,\n                4: 0x34\n            },\n            extractor: null\n        },\n        {\n            name: \"Portable Network Graphics image (under Base64)\",\n            extension: \"B64\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x69,\n                1: 0x56,\n                2: 0x42,\n                3: 0x4f,\n                4: 0x52,\n                5: 0x77,\n                6: 0x30\n            },\n            extractor: null\n        },\n        {\n            name: \"AutoCAD Drawing\",\n            extension: \"dwg,123d\",\n            mime: \"application/acad\",\n            description: \"\",\n            signature: {\n                0: 0x41,\n                1: 0x43,\n                2: 0x31,\n                3: 0x30,\n                4: [0x30, 0x31],\n                5: [0x30, 0x31, 0x32, 0x33, 0x34, 0x35],\n                6: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"AutoCAD Drawing\",\n            extension: \"dwg,dwt\",\n            mime: \"application/acad\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x41,\n                    1: 0x43,\n                    2: 0x31,\n                    3: 0x30,\n                    4: 0x31,\n                    5: 0x38,\n                    6: 0x00\n                },\n                {\n                    0: 0x41,\n                    1: 0x43,\n                    2: 0x31,\n                    3: 0x30,\n                    4: 0x32,\n                    5: 0x34,\n                    6: 0x00\n                },\n                {\n                    0: 0x41,\n                    1: 0x43,\n                    2: 0x31,\n                    3: 0x30,\n                    4: 0x32,\n                    5: 0x37,\n                    6: 0x00\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"Targa Image\",\n            extension: \"tga\",\n            mime: \"image/x-targa\",\n            description: \"\",\n            signature: [\n                { // This signature is not at the beginning of the file. The extractor works backwards.\n                    0: 0x54,\n                    1: 0x52,\n                    2: 0x55,\n                    3: 0x45,\n                    4: 0x56,\n                    5: 0x49,\n                    6: 0x53,\n                    7: 0x49,\n                    8: 0x4f,\n                    9: 0x4e,\n                    10: 0x2d,\n                    11: 0x58,\n                    12: 0x46,\n                    13: 0x49,\n                    14: 0x4c,\n                    15: 0x45,\n                    16: 0x2e\n                }\n            ],\n            extractor: extractTARGA\n        }\n    ],\n    \"Video\": [\n        { // Place before webm\n            name: \"Matroska Multimedia Container\",\n            extension: \"mkv\",\n            mime: \"video/x-matroska\",\n            description: \"\",\n            signature: {\n                31: 0x6d,\n                32: 0x61,\n                33: 0x74,\n                34: 0x72,\n                35: 0x6f,\n                36: 0x73,\n                37: 0x6b,\n                38: 0x61\n            },\n            extractor: null\n        },\n        {\n            name: \"WEBM video\",\n            extension: \"webm\",\n            mime: \"video/webm\",\n            description: \"\",\n            signature: {\n                0: 0x1a,\n                1: 0x45,\n                2: 0xdf,\n                3: 0xa3\n            },\n            extractor: null\n        },\n        { // Place before MPEG-4\n            name: \"Flash MP4 video\",\n            extension: \"f4v\",\n            mime: \"video/mp4\",\n            description: \"\",\n            signature: {\n                4: 0x66,\n                5: 0x74,\n                6: 0x79,\n                7: 0x70,\n                8: [0x66, 0x46],\n                9: 0x34,\n                10: [0x76, 0x56],\n                11: 0x20\n            },\n            extractor: null\n        },\n        {\n            name: \"MPEG-4 video\",\n            extension: \"mp4\",\n            mime: \"video/mp4\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x0,\n                    1: 0x0,\n                    2: 0x0,\n                    3: [0x18, 0x20],\n                    4: 0x66,\n                    5: 0x74,\n                    6: 0x79,\n                    7: 0x70\n                },\n                {\n                    0: 0x33, // 3gp5\n                    1: 0x67,\n                    2: 0x70,\n                    3: 0x35\n                },\n                {\n                    0: 0x0,\n                    1: 0x0,\n                    2: 0x0,\n                    3: 0x1c,\n                    4: 0x66,\n                    5: 0x74,\n                    6: 0x79,\n                    7: 0x70,\n                    8: 0x6d,\n                    9: 0x70,\n                    10: 0x34,\n                    11: 0x32,\n                    16: 0x6d, // mp41mp42isom\n                    17: 0x70,\n                    18: 0x34,\n                    19: 0x31,\n                    20: 0x6d,\n                    21: 0x70,\n                    22: 0x34,\n                    23: 0x32,\n                    24: 0x69,\n                    25: 0x73,\n                    26: 0x6f,\n                    27: 0x6d\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"M4V video\",\n            extension: \"m4v\",\n            mime: \"video/x-m4v\",\n            description: \"\",\n            signature: {\n                0: 0x0,\n                1: 0x0,\n                2: 0x0,\n                3: 0x1c,\n                4: 0x66,\n                5: 0x74,\n                6: 0x79,\n                7: 0x70,\n                8: 0x4d,\n                9: 0x34,\n                10: 0x56\n            },\n            extractor: null\n        },\n        {\n            name: \"Quicktime video\",\n            extension: \"mov\",\n            mime: \"video/quicktime\",\n            description: \"\",\n            signature: {\n                0: 0x0,\n                1: 0x0,\n                2: 0x0,\n                3: 0x14,\n                4: 0x66,\n                5: 0x74,\n                6: 0x79,\n                7: 0x70\n            },\n            extractor: null\n        },\n        {\n            name: \"Audio Video Interleave\",\n            extension: \"avi\",\n            mime: \"video/x-msvideo\",\n            description: \"\",\n            signature: {\n                0: 0x52,\n                1: 0x49,\n                2: 0x46,\n                3: 0x46,\n                8: 0x41,\n                9: 0x56,\n                10: 0x49\n            },\n            extractor: null\n        },\n        {\n            name: \"Windows Media Video\",\n            extension: \"wmv\",\n            mime: \"video/x-ms-wmv\",\n            description: \"\",\n            signature: {\n                0: 0x30,\n                1: 0x26,\n                2: 0xb2,\n                3: 0x75,\n                4: 0x8e,\n                5: 0x66,\n                6: 0xcf,\n                7: 0x11,\n                8: 0xa6,\n                9: 0xd9\n            },\n            extractor: null\n        },\n        {\n            name: \"MPEG video\",\n            extension: \"mpg\",\n            mime: \"video/mpeg\",\n            description: \"\",\n            signature: {\n                0: 0x0,\n                1: 0x0,\n                2: 0x1,\n                3: 0xba\n            },\n            extractor: null\n        },\n        {\n            name: \"Flash Video\",\n            extension: \"flv\",\n            mime: \"video/x-flv\",\n            description: \"\",\n            signature: {\n                0: 0x46,\n                1: 0x4c,\n                2: 0x56,\n                3: 0x1\n            },\n            extractor: extractFLV\n        },\n        {\n            name: \"OGG Video\",\n            extension: \"ogv,ogm,opus,ogx\",\n            mime: \"video/ogg\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x4f, // OggS\n                    1: 0x67,\n                    2: 0x67,\n                    3: 0x53,\n                    4: 0x00,\n                    5: 0x02,\n                    28: 0x01,\n                    29: 0x76, // video\n                    30: 0x69,\n                    31: 0x64,\n                    32: 0x65,\n                    33: 0x6f\n                },\n                {\n                    0: 0x4f, // OggS\n                    1: 0x67,\n                    2: 0x67,\n                    3: 0x53,\n                    4: 0x00,\n                    5: 0x02,\n                    28: 0x80,\n                    29: 0x74, // theora\n                    30: 0x68,\n                    31: 0x65,\n                    32: 0x6f,\n                    33: 0x72,\n                    34: 0x61\n                },\n                {\n                    0: 0x4f, // OggS\n                    1: 0x67,\n                    2: 0x67,\n                    3: 0x53,\n                    4: 0x00,\n                    5: 0x02,\n                    28: 0x66, // fishead\n                    29: 0x69,\n                    30: 0x73,\n                    31: 0x68,\n                    32: 0x65,\n                    33: 0x61,\n                    34: 0x64\n                }\n            ],\n            extractor: null\n        },\n    ],\n    \"Audio\": [\n        {\n            name: \"Waveform Audio\",\n            extension: \"wav\",\n            mime: \"audio/x-wav\",\n            description: \"\",\n            signature: {\n                0: 0x52,\n                1: 0x49,\n                2: 0x46,\n                3: 0x46,\n                8: 0x57,\n                9: 0x41,\n                10: 0x56,\n                11: 0x45\n            },\n            extractor: extractWAV\n        },\n        {\n            name: \"OGG audio\",\n            extension: \"ogg\",\n            mime: \"audio/ogg\",\n            description: \"\",\n            signature: {\n                0: 0x4f,\n                1: 0x67,\n                2: 0x67,\n                3: 0x53\n            },\n            extractor: null\n        },\n        {\n            name: \"Musical Instrument Digital Interface audio\",\n            extension: \"midi\",\n            mime: \"audio/midi\",\n            description: \"\",\n            signature: {\n                0: 0x4d,\n                1: 0x54,\n                2: 0x68,\n                3: 0x64\n            },\n            extractor: null\n        },\n        {\n            name: \"MPEG-3 audio\",\n            extension: \"mp3\",\n            mime: \"audio/mpeg\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x49,\n                    1: 0x44,\n                    2: 0x33\n                },\n                {\n                    0: 0xff,\n                    1: 0xfb\n                }\n            ],\n            extractor: extractMP3\n        },\n        {\n            name: \"MPEG-4 Part 14 audio\",\n            extension: \"m4a\",\n            mime: \"audio/m4a\",\n            description: \"\",\n            signature: [\n                {\n                    4: 0x66,\n                    5: 0x74,\n                    6: 0x79,\n                    7: 0x70,\n                    8: 0x4d,\n                    9: 0x34,\n                    10: 0x41\n                },\n                {\n                    0: 0x4d,\n                    1: 0x34,\n                    2: 0x41,\n                    3: 0x20\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"Free Lossless Audio Codec\",\n            extension: \"flac\",\n            mime: \"audio/x-flac\",\n            description: \"\",\n            signature: {\n                0: 0x66,\n                1: 0x4c,\n                2: 0x61,\n                3: 0x43\n            },\n            extractor: null\n        },\n        {\n            name: \"Adaptive Multi-Rate audio codec\",\n            extension: \"amr\",\n            mime: \"audio/amr\",\n            description: \"\",\n            signature: {\n                0: 0x23,\n                1: 0x21,\n                2: 0x41,\n                3: 0x4d,\n                4: 0x52,\n                5: 0x0a\n            },\n            extractor: null\n        },\n        {\n            name: \"Audacity\",\n            extension: \"au\",\n            mime: \"audio/x-au\",\n            description: \"\",\n            signature: {\n                0: 0x64, // dns.\n                1: 0x6e,\n                2: 0x73,\n                3: 0x2e,\n\n                24: 0x41, // AudacityBlockFile\n                25: 0x75,\n                26: 0x64,\n                27: 0x61,\n                28: 0x63,\n                29: 0x69,\n                30: 0x74,\n                31: 0x79,\n                32: 0x42,\n                33: 0x6c,\n                34: 0x6f,\n                35: 0x63,\n                36: 0x6b,\n                37: 0x46,\n                38: 0x69,\n                39: 0x6c,\n                40: 0x65\n            },\n            extractor: null\n        },\n        {\n            name: \"Audacity Block\",\n            extension: \"auf\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x41, // AudacityBlockFile\n                1: 0x75,\n                2: 0x64,\n                3: 0x61,\n                4: 0x63,\n                5: 0x69,\n                6: 0x74,\n                7: 0x79,\n                8: 0x42,\n                9: 0x6c,\n                10: 0x6f,\n                11: 0x63,\n                12: 0x6b,\n                13: 0x46,\n                14: 0x69,\n                15: 0x6c,\n                16: 0x65\n            },\n            extractor: null\n        },\n        {\n            name: \"Audio Interchange File\",\n            extension: \"aif\",\n            mime: \"audio/x-aiff\",\n            description: \"\",\n            signature: {\n                0: 0x46, // FORM\n                1: 0x4f,\n                2: 0x52,\n                3: 0x4d,\n                8: 0x41, // AIFF\n                9: 0x49,\n                10: 0x46,\n                11: 0x46\n            },\n            extractor: null\n        },\n        {\n            name: \"Audio Interchange File (compressed)\",\n            extension: \"aifc\",\n            mime: \"audio/x-aifc\",\n            description: \"\",\n            signature: {\n                0: 0x46, // FORM\n                1: 0x4f,\n                2: 0x52,\n                3: 0x4d,\n                8: 0x41, // AIFC\n                9: 0x49,\n                10: 0x46,\n                11: 0x43\n            },\n            extractor: null\n        }\n    ],\n    \"Documents\": [\n        {\n            name: \"Portable Document Format\",\n            extension: \"pdf\",\n            mime: \"application/pdf\",\n            description: \"\",\n            signature: {\n                0: 0x25,\n                1: 0x50,\n                2: 0x44,\n                3: 0x46\n            },\n            extractor: extractPDF\n        },\n        {\n            name: \"Portable Document Format (under Base64)\",\n            extension: \"B64\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x41,\n                1: 0x4a,\n                2: 0x56,\n                3: 0x42,\n                4: 0x45,\n                5: 0x52,\n                6: 0x69\n            },\n            extractor: null\n        },\n        { // Place before PostScript\n            name: \"Adobe PostScript\",\n            extension: \"ps,eps,ai,pfa\",\n            mime: \"application/postscript\",\n            description: \"\",\n            signature: {\n                0: 0x25,\n                1: 0x21,\n                2: 0x50,\n                3: 0x53,\n                4: 0x2d,\n                5: 0x41,\n                6: 0x64,\n                7: 0x6f,\n                8: 0x62,\n                9: 0x65\n            },\n            extractor: null\n        },\n        {\n            name: \"PostScript\",\n            extension: \"ps\",\n            mime: \"application/postscript\",\n            description: \"\",\n            signature: {\n                0: 0x25,\n                1: 0x21\n            },\n            extractor: null\n        },\n        {\n            name: \"Encapsulated PostScript\",\n            extension: \"eps,ai\",\n            mime: \"application/eps\",\n            description: \"\",\n            signature: {\n                0: 0xc5,\n                1: 0xd0,\n                2: 0xd3,\n                3: 0xc6\n            },\n            extractor: null\n        },\n        {\n            name: \"Rich Text Format\",\n            extension: \"rtf\",\n            mime: \"application/rtf\",\n            description: \"\",\n            signature: {\n                0: 0x7b,\n                1: 0x5c,\n                2: 0x72,\n                3: 0x74\n            },\n            extractor: extractRTF\n        },\n        {\n            name: \"Microsoft Office document/OLE2\",\n            extension: \"ole2,doc,xls,dot,ppt,xla,ppa,pps,pot,msi,sdw,db,vsd,msg\",\n            mime: \"application/msword,application/vnd.ms-excel,application/vnd.ms-powerpoint\",\n            description: \"Microsoft Office documents\",\n            signature: {\n                0: 0xd0,\n                1: 0xcf,\n                2: 0x11,\n                3: 0xe0,\n                4: 0xa1,\n                5: 0xb1,\n                6: 0x1a,\n                7: 0xe1\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft Office document/OLE2 (under Base64)\",\n            extension: \"B64\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x30,\n                1: 0x4d,\n                2: 0x38,\n                3: 0x52,\n                4: 0x34,\n                5: 0x4b,\n                6: 0x47,\n                7: 0x78\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft Office 2007+ document\",\n            extension: \"docx,xlsx,pptx\",\n            mime: \"application/vnd.openxmlformats-officedocument.wordprocessingml.document,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n            description: \"\",\n            signature: {\n                38: 0x5f, // _Types].xml\n                39: 0x54,\n                40: 0x79,\n                41: 0x70,\n                42: 0x65,\n                43: 0x73,\n                44: 0x5d,\n                45: 0x2e,\n                46: 0x78,\n                47: 0x6d,\n                48: 0x6c\n            },\n            extractor: extractZIP\n        },\n        {\n            name: \"Microsoft Access database\",\n            extension: \"mdb,mda,mde,mdt,fdb,psa\",\n            mime: \"application/msaccess\",\n            description: \"\",\n            signature: {\n                0: 0x00,\n                1: 0x01,\n                2: 0x00,\n                3: 0x00,\n                4: 0x53, // Standard Jet\n                5: 0x74,\n                6: 0x61,\n                7: 0x6e,\n                8: 0x64,\n                9: 0x61,\n                10: 0x72,\n                11: 0x64,\n                12: 0x20,\n                13: 0x4a,\n                14: 0x65,\n                15: 0x74\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft Access 2007+ database\",\n            extension: \"accdb,accde,accda,accdu\",\n            mime: \"application/msaccess\",\n            description: \"\",\n            signature: {\n                0: 0x00,\n                1: 0x01,\n                2: 0x00,\n                3: 0x00,\n                4: 0x53, // Standard ACE DB\n                5: 0x74,\n                6: 0x61,\n                7: 0x6e,\n                8: 0x64,\n                9: 0x61,\n                10: 0x72,\n                11: 0x64,\n                12: 0x20,\n                13: 0x41,\n                14: 0x43,\n                15: 0x45,\n                16: 0x20\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft OneNote document\",\n            extension: \"one\",\n            mime: \"application/onenote\",\n            description: \"\",\n            signature: {\n                0: 0xe4,\n                1: 0x52,\n                2: 0x5c,\n                3: 0x7b,\n                4: 0x8c,\n                5: 0xd8,\n                6: 0xa7,\n                7: 0x4d,\n                8: 0xae,\n                9: 0xb1,\n                10: 0x53,\n                11: 0x78,\n                12: 0xd0,\n                13: 0x29,\n                14: 0x96,\n                15: 0xd3\n            },\n            extractor: null\n        },\n        {\n            name: \"Outlook Express database\",\n            extension: \"dbx\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0xcf,\n                1: 0xad,\n                2: 0x12,\n                3: 0xfe,\n                4: [0x30, 0xc5, 0xc6, 0xc7],\n                11: 0x11\n            },\n            extractor: null\n        },\n        {\n            name: \"Personal Storage Table (Outlook)\",\n            extension: \"pst,ost,fdb,pab\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x21, // !BDN\n                1: 0x42,\n                2: 0x44,\n                3: 0x4e\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft Exchange Database\",\n            extension: \"edb\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                4: 0xef,\n                5: 0xcd,\n                6: 0xab,\n                7: 0x89,\n                8: [0x20, 0x23],\n                9: 0x06,\n                10: 0x00,\n                11: 0x00,\n                12: [0x00, 0x01],\n                13: 0x00,\n                14: 0x00,\n                15: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"WordPerfect document\",\n            extension: \"wpd,wp,wp5,wp6,wpp,bk!,wcm\",\n            mime: \"application/wordperfect\",\n            description: \"\",\n            signature: {\n                0: 0xff,\n                1: 0x57,\n                2: 0x50,\n                3: 0x43,\n                7: [0x00, 0x01, 0x02],\n                8: 0x01,\n                9: 0x0a\n            },\n            extractor: null\n        },\n        {\n            name: \"EPUB e-book\",\n            extension: \"epub\",\n            mime: \"application/epub+zip\",\n            description: \"\",\n            signature: {\n                0: 0x50,\n                1: 0x4b,\n                2: 0x3,\n                3: 0x4,\n                30: 0x6d, // mimetypeapplication/epub_zip\n                31: 0x69,\n                32: 0x6d,\n                33: 0x65,\n                34: 0x74,\n                35: 0x79,\n                36: 0x70,\n                37: 0x65,\n                38: 0x61,\n                39: 0x70,\n                40: 0x70,\n                41: 0x6c,\n                42: 0x69,\n                43: 0x63,\n                44: 0x61,\n                45: 0x74,\n                46: 0x69,\n                47: 0x6f,\n                48: 0x6e,\n                49: 0x2f,\n                50: 0x65,\n                51: 0x70,\n                52: 0x75,\n                53: 0x62,\n                54: 0x2b,\n                55: 0x7a,\n                56: 0x69,\n                57: 0x70\n            },\n            extractor: extractZIP\n        },\n    ],\n    \"Applications\": [\n        {\n            name: \"Windows Portable Executable\",\n            extension: \"exe,dll,drv,vxd,sys,ocx,vbx,com,fon,scr\",\n            mime: \"application/vnd.microsoft.portable-executable\",\n            description: \"\",\n            signature: {\n                0: 0x4d,\n                1: 0x5a,\n                3: [0x0, 0x1, 0x2],\n                5: [0x0, 0x1, 0x2]\n            },\n            extractor: extractMZPE\n        },\n        {\n            name: \"Executable and Linkable Format\",\n            extension: \"elf,bin,axf,o,prx,so\",\n            mime: \"application/x-executable\",\n            description: \"Executable and Linkable Format file. No standard file extension.\",\n            signature: {\n                0: 0x7f,\n                1: 0x45,\n                2: 0x4c,\n                3: 0x46\n            },\n            extractor: extractELF\n        },\n        {\n            name: \"MacOS Mach-O object\",\n            extension: \"dylib\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0xca,\n                    1: 0xfe,\n                    2: 0xba,\n                    3: 0xbe,\n                    4: 0x00,\n                    5: 0x00,\n                    6: 0x00,\n                    7: [0x01, 0x02, 0x03]\n                },\n                {\n                    0: 0xce,\n                    1: 0xfa,\n                    2: 0xed,\n                    3: 0xfe,\n                    4: 0x07,\n                    5: 0x00,\n                    6: 0x00,\n                    7: 0x00,\n                    8: [0x01, 0x02, 0x03]\n                }\n            ],\n            extractor: extractMACHO\n        },\n        {\n            name: \"MacOS Mach-O 64-bit object\",\n            extension: \"dylib\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0xcf,\n                1: 0xfa,\n                2: 0xed,\n                3: 0xfe\n            },\n            extractor: extractMACHO\n        },\n        {\n            name: \"Adobe Flash\",\n            extension: \"swf\",\n            mime: \"application/x-shockwave-flash\",\n            description: \"\",\n            signature: {\n                0: [0x43, 0x46],\n                1: 0x57,\n                2: 0x53,\n            },\n            extractor: null\n        },\n        {\n            name: \"Java Class\",\n            extension: \"class\",\n            mime: \"application/java-vm\",\n            description: \"\",\n            signature: {\n                0: 0xca,\n                1: 0xfe,\n                2: 0xba,\n                3: 0xbe\n            },\n            extractor: null\n        },\n        {\n            name: \"Dalvik Executable\",\n            extension: \"dex\",\n            mime: \"application/octet-stream\",\n            description: \"Dalvik Executable as used by Android\",\n            signature: {\n                0: 0x64,\n                1: 0x65,\n                2: 0x78,\n                3: 0x0a,\n                4: 0x30,\n                5: 0x33,\n                6: 0x35,\n                7: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"Google Chrome Extension\",\n            extension: \"crx\",\n            mime: \"application/crx\",\n            description: \"Google Chrome extension or packaged app\",\n            signature: {\n                0: 0x43,\n                1: 0x72,\n                2: 0x32,\n                3: 0x34\n            },\n            extractor: null\n        },\n    ],\n    \"Archives\": [\n        {\n            name: \"PKZIP archive\",\n            extension: \"zip\",\n            mime: \"application/zip\",\n            description: \"\",\n            signature: {\n                0: 0x50,\n                1: 0x4b,\n                2: [0x3, 0x5, 0x7],\n                3: [0x4, 0x6, 0x8]\n            },\n            extractor: extractZIP\n        },\n        {\n            name: \"PKZIP archive (under Base64)\",\n            extension: \"B64\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x55,\n                1: 0x45,\n                2: 0x73,\n                3: 0x44,\n                4: 0x42,\n                5: 0x42\n            },\n            extractor: null\n        },\n        {\n            name: \"TAR archive\",\n            extension: \"tar\",\n            mime: \"application/x-tar\",\n            description: \"\",\n            signature: {\n                257: 0x75, // ustar\n                258: 0x73,\n                259: 0x74,\n                260: 0x61,\n                261: 0x72\n            },\n            extractor: extractTAR\n        },\n        {\n            name: \"Roshal Archive\",\n            extension: \"rar\",\n            mime: \"application/x-rar-compressed\",\n            description: \"\",\n            signature: {\n                0: 0x52,\n                1: 0x61,\n                2: 0x72,\n                3: 0x21,\n                4: 0x1a,\n                5: 0x7,\n                6: [0x0, 0x1]\n            },\n            extractor: null\n        },\n        {\n            name: \"Gzip\",\n            extension: \"gz\",\n            mime: \"application/gzip\",\n            description: \"\",\n            signature: {\n                0: 0x1f,\n                1: 0x8b,\n                2: 0x8\n            },\n            extractor: extractGZIP\n        },\n        {\n            name: \"Bzip2\",\n            extension: \"bz2\",\n            mime: \"application/x-bzip2\",\n            description: \"\",\n            signature: {\n                0: 0x42,\n                1: 0x5a,\n                2: 0x68\n            },\n            extractor: extractBZIP2\n        },\n        {\n            name: \"7zip\",\n            extension: \"7z\",\n            mime: \"application/x-7z-compressed\",\n            description: \"\",\n            signature: {\n                0: 0x37,\n                1: 0x7a,\n                2: 0xbc,\n                3: 0xaf,\n                4: 0x27,\n                5: 0x1c\n            },\n            extractor: null\n        },\n        {\n            name: \"Zlib Deflate\",\n            extension: \"zlib\",\n            mime: \"application/x-deflate\",\n            description: \"\",\n            signature: {\n                0: 0x78,\n                1: [0x1, 0x9c, 0xda, 0x5e]\n            },\n            extractor: extractZlib\n        },\n        {\n            name: \"xz compression\",\n            extension: \"xz\",\n            mime: \"application/x-xz\",\n            description: \"\",\n            signature: {\n                0: 0xfd,\n                1: 0x37,\n                2: 0x7a,\n                3: 0x58,\n                4: 0x5a,\n                5: 0x0\n            },\n            extractor: extractXZ\n        },\n        {\n            name: \"Tarball\",\n            extension: \"tar.z\",\n            mime: \"application/x-gtar\",\n            description: \"\",\n            signature: {\n                0: 0x1f,\n                1: [0x9d, 0xa0]\n            },\n            extractor: null\n        },\n        {\n            name: \"ISO disk image\",\n            extension: \"iso\",\n            mime: \"application/octet-stream\",\n            description: \"ISO 9660 CD/DVD image file\",\n            signature: [\n                {\n                    0x8001: 0x43,\n                    0x8002: 0x44,\n                    0x8003: 0x30,\n                    0x8004: 0x30,\n                    0x8005: 0x31\n                },\n                {\n                    0x8801: 0x43,\n                    0x8802: 0x44,\n                    0x8803: 0x30,\n                    0x8804: 0x30,\n                    0x8805: 0x31\n                },\n                {\n                    0x9001: 0x43,\n                    0x9002: 0x44,\n                    0x9003: 0x30,\n                    0x9004: 0x30,\n                    0x9005: 0x31\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"Virtual Machine Disk\",\n            extension: \"vmdk\",\n            mime: \"application/vmdk,application/x-virtualbox-vmdk\",\n            description: \"\",\n            signature: {\n                0: 0x4b,\n                1: 0x44,\n                2: 0x4d,\n                3: 0x56,\n                5: 0x00,\n                6: 0x00,\n                7: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Virtual Hard Drive\",\n            extension: \"vhd\",\n            mime: \"application/x-vhd\",\n            description: \"\",\n            signature: {\n                0: 0x63, // conectix\n                1: 0x6f,\n                2: 0x6e,\n                3: 0x65,\n                4: 0x63,\n                5: 0x74,\n                6: 0x69,\n                7: 0x78\n            },\n            extractor: null\n        },\n        {\n            name: \"Macintosh disk image\",\n            extension: \"dmf,dmg\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x78,\n                1: 0x01,\n                2: 0x73,\n                3: 0x0d,\n                4: 0x62,\n                5: 0x62,\n                6: 0x60,\n                7: 0x60\n            },\n            extractor: null\n        },\n        {\n            name: \"ARJ Archive\",\n            extension: \"arj\",\n            mime: \"application/x-arj-compressed\",\n            description: \"\",\n            signature: {\n                0: 0x60,\n                1: 0xea,\n                8: [0x0, 0x10, 0x14],\n                9: 0x0,\n                10: 0x2\n            },\n            extractor: null\n        },\n        {\n            name: \"WinAce Archive\",\n            extension: \"ace\",\n            mime: \"application/x-ace-compressed\",\n            description: \"\",\n            signature: {\n                7: 0x2a, // **ACE**\n                8: 0x2a,\n                9: 0x41,\n                10: 0x43,\n                11: 0x45,\n                12: 0x2a,\n                13: 0x2a\n            },\n            extractor: null\n        },\n        {\n            name: \"Macintosh BinHex Encoded File\",\n            extension: \"hqx\",\n            mime: \"application/mac-binhex\",\n            description: \"\",\n            signature: {\n                11: 0x6d,  // must be converted with BinHex\n                12: 0x75,\n                13: 0x73,\n                14: 0x74,\n                15: 0x20,\n                16: 0x62,\n                17: 0x65,\n                18: 0x20,\n                19: 0x63,\n                20: 0x6f,\n                21: 0x6e,\n                22: 0x76,\n                23: 0x65,\n                24: 0x72,\n                25: 0x74,\n                26: 0x65,\n                27: 0x64,\n                28: 0x20,\n                29: 0x77,\n                30: 0x69,\n                31: 0x74,\n                32: 0x68,\n                33: 0x20,\n                34: 0x42,\n                35: 0x69,\n                36: 0x6e,\n                37: 0x48,\n                38: 0x65,\n                39: 0x78\n            },\n            extractor: null\n        },\n        {\n            name: \"ALZip Archive\",\n            extension: \"alz\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x41, // ALZ\n                1: 0x4c,\n                2: 0x5a,\n                3: 0x01,\n                4: 0x0a,\n                5: 0x0,\n                6: 0x0,\n                7: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"KGB Compressed Archive\",\n            extension: \"kgb\",\n            mime: \"application/x-kgb-compressed\",\n            description: \"\",\n            signature: {\n                0: 0x4b, // KGB_arch -\n                1: 0x47,\n                2: 0x42,\n                3: 0x5f,\n                4: 0x61,\n                5: 0x72,\n                6: 0x63,\n                7: 0x68,\n                8: 0x20,\n                9: 0x2d\n            },\n            extractor: null\n        },\n        {\n            name: \"Microsoft Cabinet\",\n            extension: \"cab\",\n            mime: \"vnd.ms-cab-compressed\",\n            description: \"\",\n            signature: {\n                0: 0x4d,\n                1: 0x53,\n                2: 0x43,\n                3: 0x46,\n                4: 0x00,\n                5: 0x00,\n                6: 0x00,\n                7: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Jar Archive\",\n            extension: \"jar\",\n            mime: \"application/java-archive\",\n            description: \"\",\n            signature: {\n                0: 0x5f,\n                1: 0x27,\n                2: 0xa8,\n                3: 0x89\n            },\n            extractor: null\n        },\n        {\n            name: \"Jar Archive\",\n            extension: \"jar\",\n            mime: \"application/java-archive\",\n            description: \"\",\n            signature: {\n                0: 0x50,\n                1: 0x4B,\n                2: 0x03,\n                3: 0x04,\n                4: 0x14,\n                5: 0x00,\n                6: 0x08,\n                7: 0x00,\n                8: 0x08,\n                9: 0x00\n            },\n            extractor: extractZIP\n        },\n        {\n            name: \"lzop compressed\",\n            extension: \"lzop,lzo\",\n            mime: \"application/x-lzop\",\n            description: \"\",\n            signature: {\n                0: 0x89,\n                1: 0x4c, // LZO\n                2: 0x5a,\n                3: 0x4f,\n                4: 0x00,\n                5: 0x0d,\n                6: 0x0a,\n                7: 0x1a\n            },\n            extractor: extractLZOP\n        },\n        {\n            name: \"Linux deb package\",\n            extension: \"deb\",\n            mime: \"application/vnd.debian.binary-package\",\n            description: \"\",\n            signature: {\n                0: 0x21,\n                1: 0x3C,\n                2: 0x61,\n                3: 0x72,\n                4: 0x63,\n                5: 0x68,\n                6: 0x3e\n            },\n            extractor: extractDEB\n        },\n        {\n            name: \"Apple Disk Image\",\n            extension: \"dmg\",\n            mime: \"application/x-apple-diskimage\",\n            description: \"\",\n            signature: {\n                0: 0x78,\n                1: 0x01,\n                2: 0x73,\n                3: 0x0d,\n                4: 0x62,\n                5: 0x62,\n                6: 0x60\n            },\n            extractor: null\n        }\n    ],\n    \"Miscellaneous\": [\n        {\n            name: \"UTF-8 text\",\n            extension: \"txt\",\n            mime: \"text/plain\",\n            description: \"UTF-8 encoded Unicode byte order mark, commonly but not exclusively seen in text files.\",\n            signature: {\n                0: 0xef,\n                1: 0xbb,\n                2: 0xbf\n            },\n            extractor: null\n        },\n        { // Place before UTF-16 LE text\n            name: \"UTF-32 LE text\",\n            extension: \"utf32le\",\n            mime: \"charset/utf32le\",\n            description: \"Little-endian UTF-32 encoded Unicode byte order mark.\",\n            signature: {\n                0: 0xff,\n                1: 0xfe,\n                2: 0x00,\n                3: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"UTF-16 LE text\",\n            extension: \"utf16le\",\n            mime: \"charset/utf16le\",\n            description: \"Little-endian UTF-16 encoded Unicode byte order mark.\",\n            signature: {\n                0: 0xff,\n                1: 0xfe\n            },\n            extractor: null\n        },\n        {\n            name: \"Web Open Font Format\",\n            extension: \"woff\",\n            mime: \"application/font-woff\",\n            description: \"\",\n            signature: {\n                0: 0x77,\n                1: 0x4f,\n                2: 0x46,\n                3: 0x46,\n                4: 0x0,\n                5: 0x1,\n                6: 0x0,\n                7: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"Web Open Font Format 2\",\n            extension: \"woff2\",\n            mime: \"application/font-woff\",\n            description: \"\",\n            signature: {\n                0: 0x77,\n                1: 0x4f,\n                2: 0x46,\n                3: 0x32,\n                4: 0x0,\n                5: 0x1,\n                6: 0x0,\n                7: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"Embedded OpenType font\",\n            extension: \"eot\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: [\n                {\n                    8: 0x2,\n                    9: 0x0,\n                    10: 0x1,\n                    34: 0x4c,\n                    35: 0x50\n                },\n                {\n                    8: 0x1,\n                    9: 0x0,\n                    10: 0x0,\n                    34: 0x4c,\n                    35: 0x50\n                },\n                {\n                    8: 0x2,\n                    9: 0x0,\n                    10: 0x2,\n                    34: 0x4c,\n                    35: 0x50\n                },\n            ],\n            extractor: null\n        },\n        {\n            name: \"TrueType Font\",\n            extension: \"ttf\",\n            mime: \"application/font-sfnt\",\n            description: \"\",\n            signature: {\n                0: 0x0,\n                1: 0x1,\n                2: 0x0,\n                3: 0x0,\n                4: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"OpenType Font\",\n            extension: \"otf\",\n            mime: \"application/font-sfnt\",\n            description: \"\",\n            signature: {\n                0: 0x4f,\n                1: 0x54,\n                2: 0x54,\n                3: 0x4f,\n                4: 0x0\n            },\n            extractor: null\n        },\n        {\n            name: \"SQLite\",\n            extension: \"sqlite\",\n            mime: \"application/x-sqlite3\",\n            description: \"\",\n            signature: {\n                0: 0x53,\n                1: 0x51,\n                2: 0x4c,\n                3: 0x69\n            },\n            extractor: extractSQLITE\n        },\n        {\n            name: \"BitTorrent link\",\n            extension: \"torrent\",\n            mime: \"application/x-bittorrent\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x64, // d8:announce##:\n                    1: 0x38,\n                    2: 0x3a,\n                    3: 0x61,\n                    4: 0x6e,\n                    5: 0x6e,\n                    6: 0x6f,\n                    7: 0x75,\n                    8: 0x6e,\n                    9: 0x63,\n                    10: 0x65,\n                    11: 0x23,\n                    12: 0x23,\n                    13: 0x3a\n                },\n                {\n                    0: 0x64, // d4:infod\n                    1: 0x34,\n                    2: 0x3a,\n                    3: 0x69,\n                    4: 0x6e,\n                    5: 0x66,\n                    6: 0x6f,\n                    7: 0x64,\n                    8: [0x34, 0x35, 0x36],\n                    9: 0x3a\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"Cryptocurrency wallet\",\n            extension: \"wallet\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x00,\n                1: 0x00,\n                2: 0x00,\n                3: 0x00,\n                4: 0x01,\n                5: 0x00,\n                6: 0x00,\n                7: 0x00,\n                8: 0x00,\n                9: 0x00,\n                10: 0x00,\n                11: 0x00,\n                12: 0x62,\n                13: 0x31,\n                14: 0x05,\n                15: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Registry fragment\",\n            extension: \"hbin\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x68, // hbin\n                1: 0x62,\n                2: 0x69,\n                3: 0x6e,\n                4: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Registry script\",\n            extension: \"rgs\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x48, // HKCR\n                1: 0x4b,\n                2: 0x43,\n                3: 0x52,\n                4: 0x0d,\n                5: 0x0a,\n                6: 0x5c,\n                7: 0x7b\n            },\n            extractor: null\n        },\n        {\n            name: \"WinNT Registry Hive\",\n            extension: \"registry\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x72,\n                1: 0x65,\n                2: 0x67,\n                3: 0x66\n            },\n            extractor: null\n        },\n        {\n            name: \"Windows Event Log\",\n            extension: \"evt\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x30,\n                1: 0x00,\n                2: 0x00,\n                3: 0x00,\n                4: 0x4c,\n                5: 0x66,\n                6: 0x4c,\n                7: 0x65\n            },\n            extractor: extractEVT\n        },\n        {\n            name: \"Windows Event Log\",\n            extension: \"evtx\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x45, // ElfFile\n                1: 0x6c,\n                2: 0x66,\n                3: 0x46,\n                4: 0x69,\n                5: 0x6c,\n                6: 0x65\n            },\n            extractor: extractEVTX\n        },\n        {\n            name: \"Windows Pagedump\",\n            extension: \"dmp\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x50, // PAGEDU(MP|64)\n                1: 0x41,\n                2: 0x47,\n                3: 0x45,\n                4: 0x44,\n                5: 0x55,\n                6: [0x4d, 0x36],\n                7: [0x50, 0x34]\n            },\n            extractor: extractDMP\n        },\n        {\n            name: \"Windows Prefetch\",\n            extension: \"pf\",\n            mime: \"application/x-pf\",\n            description: \"\",\n            signature: {\n                0: [0x11, 0x17, 0x1a],\n                1: 0x0,\n                2: 0x0,\n                3: 0x0,\n                4: 0x53,\n                5: 0x43,\n                6: 0x43,\n                7: 0x41\n            },\n            extractor: extractPF\n        },\n        {\n            name: \"Windows Prefetch (Win 10)\",\n            extension: \"pf\",\n            mime: \"application/x-pf\",\n            description: \"\",\n            signature: {\n                0: 0x4d,\n                1: 0x41,\n                2: 0x4d,\n                3: 0x04,\n                7: 0x0\n            },\n            extractor: extractPFWin10\n        },\n        {\n            name: \"PList (XML)\",\n            extension: \"plist\",\n            mime: \"application/xml\",\n            description: \"\",\n            signature: {\n                39: 0x3c, // <!DOCTYPE plist\n                40: 0x21,\n                41: 0x44,\n                42: 0x4f,\n                43: 0x43,\n                44: 0x54,\n                45: 0x59,\n                46: 0x50,\n                47: 0x45,\n                48: 0x20,\n                49: 0x70,\n                50: 0x6c,\n                51: 0x69,\n                52: 0x73,\n                53: 0x74\n            },\n            extractor: extractPListXML\n        },\n        {\n            name: \"PList (binary)\",\n            extension: \"bplist,plist,ipmeta,abcdp,mdbackup,mdinfo,strings,nib,ichat,qtz,webbookmark,webhistory\",\n            mime: \"application/x-plist\",\n            description: \"\",\n            signature: {\n                0: 0x62, // bplist00\n                1: 0x70,\n                2: 0x6c,\n                3: 0x69,\n                4: 0x73,\n                5: 0x74,\n                6: 0x30,\n                7: 0x30\n            },\n            extractor: null\n        },\n        {\n            name: \"MacOS X Keychain\",\n            extension: \"keychain\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x6b, // kych\n                1: 0x79,\n                2: 0x63,\n                3: 0x68,\n                4: 0x00,\n                5: 0x01\n            },\n            extractor: extractMacOSXKeychain\n        },\n        {\n            name: \"TCP Packet\",\n            extension: \"tcp\",\n            mime: \"application/tcp\",\n            description: \"\",\n            signature: {\n                12: 0x08,\n                13: 0x00,\n                14: 0x45,\n                15: 0x00,\n                21: 0x00,\n                22: b => b >= 0x01 && b <= 0x80,\n                23: 0x06\n            },\n            extractor: null\n        },\n        {\n            name: \"UDP Packet\",\n            extension: \"udp\",\n            mime: \"application/udp\",\n            description: \"\",\n            signature: {\n                12: 0x08,\n                13: 0x00,\n                14: 0x45,\n                15: 0x00,\n                16: [0x00, 0x01, 0x02, 0x03, 0x04, 0x05],\n                22: b => b >= 0x01 && b <= 0x80,\n                23: 0x11\n            },\n            extractor: null\n        },\n        {\n            name: \"Compiled HTML\",\n            extension: \"chm,chw,chi\",\n            mime: \"application/vnd.ms-htmlhelp\",\n            description: \"\",\n            signature: {\n                0: 0x49, // ITSF\n                1: 0x54,\n                2: 0x53,\n                3: 0x46,\n                4: 0x03,\n                5: 0x00,\n                6: 0x00,\n                7: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Windows Password\",\n            extension: \"pwl\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0xe3,\n                1: 0x82,\n                2: 0x85,\n                3: 0x96\n            },\n            extractor: null\n        },\n        {\n            name: \"Bitlocker recovery key\",\n            extension: \"bitlocker\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0xff,\n                1: 0xfe,\n                2: 0x42,\n                3: 0x00,\n                4: 0x69,\n                5: 0x00,\n                6: 0x74,\n                7: 0x00,\n                8: 0x4c,\n                9: 0x00,\n                10: 0x6f,\n                11: 0x00,\n                12: 0x63,\n                13: 0x00,\n                14: 0x6b,\n                15: 0x00,\n                16: 0x65,\n                17: 0x00,\n                18: 0x72,\n                19: 0x00,\n                20: 0x20,\n                21: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Certificate\",\n            extension: \"cer,cat,p7b,p7c,p7m,p7s,swz,rsa,crl,crt,der\",\n            mime: \"application/pkix-cert\",\n            description: \"\",\n            signature: {\n                0: 0x30,\n                1: 0x82,\n                4: [0x06, 0x0a, 0x30]\n            },\n            extractor: null\n        },\n        {\n            name: \"Certificate\",\n            extension: \"cat,swz,p7m\",\n            mime: \"application/vnd.ms-pki.seccat\",\n            description: \"\",\n            signature: {\n                0: 0x30,\n                1: 0x83,\n                2: b => b !== 0x00,\n                5: 0x06,\n                6: 0x09\n            },\n            extractor: null\n        },\n        {\n            name: \"PGP pubring\",\n            extension: \"pkr,gpg\",\n            mime: \"application/pgp-keys\",\n            description: \"\",\n            signature: {\n                0: 0x99,\n                1: 0x01,\n                2: [0x0d, 0xa2],\n                3: 0x04\n            },\n            extractor: null\n        },\n        {\n            name: \"PGP secring\",\n            extension: \"skr\",\n            mime: \"application/pgp-keys\",\n            description: \"\",\n            signature: [\n                {\n                    0: 0x95,\n                    1: 0x01,\n                    2: 0xcf,\n                    3: 0x04\n                },\n                {\n                    0: 0x95,\n                    1: 0x03,\n                    2: 0xc6,\n                    3: 0x04\n                },\n                {\n                    0: 0x95,\n                    1: 0x05,\n                    2: 0x86,\n                    3: 0x04\n                }\n            ],\n            extractor: null\n        },\n        {\n            name: \"PGP Safe\",\n            extension: \"pgd\",\n            mime: \"application/pgp-keys\",\n            description: \"\",\n            signature: {\n                0: 0x50, // PGPdMAIN\n                1: 0x47,\n                2: 0x50,\n                3: 0x64,\n                4: 0x4d,\n                5: 0x41,\n                6: 0x49,\n                7: 0x4e,\n                8: 0x60,\n                9: 0x01,\n                10: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Task Scheduler\",\n            extension: \"job\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: [0x00, 0x01, 0x02, 0x03],\n                1: [0x05, 0x06],\n                2: 0x01,\n                3: 0x00,\n                20: 0x46,\n                21: 0x00\n            },\n            extractor: null\n        },\n        {\n            name: \"Windows Shortcut\",\n            extension: \"lnk\",\n            mime: \"application/x-ms-shortcut\",\n            description: \"\",\n            signature: {\n                0: 0x4c,\n                1: 0x00,\n                2: 0x00,\n                3: 0x00,\n                4: 0x01,\n                5: 0x14,\n                6: 0x02,\n                7: 0x00,\n                8: 0x00,\n                9: 0x00,\n                10: 0x00,\n                11: 0x00,\n                12: 0xc0,\n                13: 0x00,\n                14: 0x00,\n                15: 0x00,\n                16: 0x00,\n                17: 0x00,\n                18: 0x00,\n                19: 0x46\n            },\n            extractor: extractLNK\n        },\n        {\n            name: \"Bash\",\n            extension: \"bash\",\n            mime: \"application/bash\",\n            description: \"\",\n            signature: {\n                0: 0x23, // #!/bin/bash\n                1: 0x21,\n                2: 0x2f,\n                3: 0x62,\n                4: 0x69,\n                5: 0x6e,\n                6: 0x2f,\n                7: 0x62,\n                8: 0x61,\n                9: 0x73,\n                10: 0x68,\n            },\n            extractor: null\n        },\n        {\n            name: \"Shell\",\n            extension: \"sh\",\n            mime: \"application/sh\",\n            description: \"\",\n            signature: {\n                0: 0x23, // #!/bin/sh\n                1: 0x21,\n                2: 0x2f,\n                3: 0x62,\n                4: 0x69,\n                5: 0x6e,\n                6: 0x2f,\n                7: 0x73,\n                8: 0x68,\n            },\n            extractor: null\n        },\n        {\n            name: \"Python\",\n            extension: \"py,pyc,pyd,pyo,pyw,pyz\",\n            mime: \"application/python\",\n            description: \"\",\n            signature: {\n                0: 0x23, // #!/usr/bin/python(2|3)\n                1: 0x21,\n                2: 0x2f,\n                3: 0x75,\n                4: 0x73,\n                5: 0x72,\n                6: 0x2f,\n                7: 0x62,\n                8: 0x69,\n                9: 0x6e,\n                10: 0x2f,\n                11: 0x70,\n                12: 0x79,\n                13: 0x74,\n                14: 0x68,\n                15: 0x6f,\n                16: 0x6e,\n                17: [0x32, 0x33, 0xa, 0xd],\n            },\n            extractor: null\n        },\n        {\n            name: \"Ruby\",\n            extension: \"rb\",\n            mime: \"application/ruby\",\n            description: \"\",\n            signature: {\n                0: 0x23, // #!/usr/bin/ruby\n                1: 0x21,\n                2: 0x2f,\n                3: 0x75,\n                4: 0x73,\n                5: 0x72,\n                6: 0x2f,\n                7: 0x62,\n                8: 0x69,\n                9: 0x6e,\n                10: 0x2f,\n                11: 0x72,\n                12: 0x75,\n                13: 0x62,\n                14: 0x79,\n            },\n            extractor: null\n        },\n        {\n            name: \"perl\",\n            extension: \"pl,pm,t,pod\",\n            mime: \"application/perl\",\n            description: \"\",\n            signature: {\n                0: 0x23, // #!/usr/bin/perl\n                1: 0x21,\n                2: 0x2f,\n                3: 0x75,\n                4: 0x73,\n                5: 0x72,\n                6: 0x2f,\n                7: 0x62,\n                8: 0x69,\n                9: 0x6e,\n                10: 0x2f,\n                11: 0x70,\n                12: 0x65,\n                13: 0x72,\n                14: 0x6c,\n            },\n            extractor: null\n        },\n        {\n            name: \"php\",\n            extension: \"php,phtml,php3,php4,php5,php7,phps,php-s,pht,phar\",\n            mime: \"application/php\",\n            description: \"\",\n            signature: {\n                0: 0x3c, // <?php\n                1: 0x3f,\n                2: 0x70,\n                3: 0x68,\n                4: 0x70,\n            },\n            extractor: null\n        },\n        {\n            name: \"Smile\",\n            extension: \"sml\",\n            mime: \"\tapplication/x-jackson-smile\",\n            description: \"\",\n            signature: {\n                0: 0x3a,\n                1: 0x29,\n                2: 0xa\n            },\n            extractor: null\n        },\n        {\n            name: \"Lua Bytecode\",\n            extension: \"luac\",\n            mime: \"application/x-lua\",\n            description: \"\",\n            signature: {\n                0: 0x1b,\n                1: 0x4c,\n                2: 0x75,\n                3: 0x61\n            },\n            extractor: null\n        },\n        {\n            name: \"WebAssembly binary\",\n            extension: \"wasm\",\n            mime: \"application/octet-stream\",\n            description: \"\",\n            signature: {\n                0: 0x00,\n                1: 0x61,\n                2: 0x73,\n                3: 0x6d\n            },\n            extractor: null\n        }\n    ]\n};\n\n\n/**\n * JPEG extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractJPEG(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    while (stream.hasMore()) {\n        const marker = stream.getBytes(2);\n        if (marker[0] !== 0xff) throw new Error(`Invalid marker while parsing JPEG at pos ${stream.position}: ${marker}`);\n\n        let segmentSize = 0;\n        switch (marker[1]) {\n            // No length\n            case 0xd8: // Start of Image\n            case 0x01: // For temporary use in arithmetic coding\n                break;\n            case 0xd9: // End found\n                return stream.carve();\n\n            // Variable size segment\n            case 0xc0: // Start of frame (Baseline DCT)\n            case 0xc1: // Start of frame (Extended sequential DCT)\n            case 0xc2: // Start of frame (Progressive DCT)\n            case 0xc3: // Start of frame (Lossless sequential)\n            case 0xc4: // Define Huffman Table\n            case 0xc5: // Start of frame (Differential sequential DCT)\n            case 0xc6: // Start of frame (Differential progressive DCT)\n            case 0xc7: // Start of frame (Differential lossless)\n            case 0xc8: // Reserved for JPEG extensions\n            case 0xc9: // Start of frame (Extended sequential DCT)\n            case 0xca: // Start of frame (Progressive DCT)\n            case 0xcb: // Start of frame (Lossless sequential)\n            case 0xcc: // Define arithmetic conditioning table\n            case 0xcd: // Start of frame (Differential sequential DCT)\n            case 0xce: // Start of frame (Differential progressive DCT)\n            case 0xcf: // Start of frame (Differential lossless)\n            case 0xdb: // Define Quantization Table\n            case 0xde: // Define hierarchical progression\n            case 0xe0: // Application-specific\n            case 0xe1: // Application-specific\n            case 0xe2: // Application-specific\n            case 0xe3: // Application-specific\n            case 0xe4: // Application-specific\n            case 0xe5: // Application-specific\n            case 0xe6: // Application-specific\n            case 0xe7: // Application-specific\n            case 0xe8: // Application-specific\n            case 0xe9: // Application-specific\n            case 0xea: // Application-specific\n            case 0xeb: // Application-specific\n            case 0xec: // Application-specific\n            case 0xed: // Application-specific\n            case 0xee: // Application-specific\n            case 0xef: // Application-specific\n            case 0xfe: // Comment\n                segmentSize = stream.readInt(2, \"be\");\n                stream.position += segmentSize - 2;\n                break;\n\n            // 1 byte\n            case 0xdf: // Expand reference image\n                stream.position++;\n                break;\n\n            // 2 bytes\n            case 0xdc: // Define number of lines\n            case 0xdd: // Define restart interval\n                stream.position += 2;\n                break;\n\n            // Start scan\n            case 0xda: // Start of scan\n                segmentSize = stream.readInt(2, \"be\");\n                stream.position += segmentSize - 2;\n                stream.continueUntil(0xff);\n                break;\n\n            // Continue through encoded data\n            case 0x00: // Byte stuffing\n            case 0xd0: // Restart\n            case 0xd1: // Restart\n            case 0xd2: // Restart\n            case 0xd3: // Restart\n            case 0xd4: // Restart\n            case 0xd5: // Restart\n            case 0xd6: // Restart\n            case 0xd7: // Restart\n                stream.continueUntil(0xff);\n                break;\n\n            default:\n                stream.continueUntil(0xff);\n                break;\n        }\n    }\n\n    throw new Error(\"Unable to parse JPEG successfully\");\n}\n\n\n/**\n * GIF extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractGIF(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to application extension block.\n    stream.continueUntil([0x21, 0xff]);\n\n    // Move to Graphic Control Extension for frame #1.\n    stream.continueUntil([0x21, 0xf9]);\n    stream.moveForwardsBy(2);\n\n    while (stream.hasMore()) {\n        // Move to Image descriptor.\n        stream.moveForwardsBy(stream.readInt(1) + 1);\n\n        // Move past Image descriptor to the image data.\n        stream.moveForwardsBy(11);\n\n        // Loop until next Graphic Control Extension.\n        while (!Array.from(stream.getBytes(2)).equals([0x21, 0xf9])) {\n            stream.moveBackwardsBy(2);\n            stream.moveForwardsBy(stream.readInt(1));\n            if (!stream.readInt(1))\n                break;\n            stream.moveBackwardsBy(1);\n        }\n\n        // When the end of the file is [0x00, 0x3b], end.\n        if (stream.readInt(1) === 0x3b)\n            break;\n\n        stream.moveForwardsBy(1);\n    }\n    return stream.carve();\n}\n\n\n/**\n * Portable executable extractor.\n * Assumes that the offset refers to an MZ header.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractMZPE(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Read pointer to PE header\n    stream.moveTo(0x3c);\n    const peAddress = stream.readInt(4, \"le\");\n\n    // Move to PE header\n    stream.moveTo(peAddress);\n\n    // Get number of sections\n    stream.moveForwardsBy(6);\n    const numSections = stream.readInt(2, \"le\");\n\n    // Read Optional Header Magic to determine the state of the image file\n    // 0x10b = normal executable, 0x107 = ROM image, 0x20b = PE32+ executable\n    stream.moveForwardsBy(16);\n    const optionalMagic = stream.readInt(2, \"le\");\n    const pe32Plus = optionalMagic === 0x20b;\n\n    // Move to Data Directory\n    const dataDirectoryOffset = pe32Plus ? 112 : 96;\n    stream.moveForwardsBy(dataDirectoryOffset - 2);\n\n    // Read Certificate Table address and size (IMAGE_DIRECTORY_ENTRY_SECURITY)\n    stream.moveForwardsBy(32);\n    const certTableAddress = stream.readInt(4, \"le\");\n    const certTableSize = stream.readInt(4, \"le\");\n\n    // PE files can contain extra data appended to the end of the file called an \"overlay\".\n    // This data is not covered by the PE header and could be any arbitrary format, so its\n    // length cannot be determined without contextual information.\n    // However, the Attribute Certificate Table is stored in the overlay - usually right at\n    // the end. Therefore, if this table is defined, we can use its offset and size to carve\n    // out the entire PE file, including the overlay.\n    // If the Certificate Table is not defined, we continue to parse the PE file as best we\n    // can up to the end of the final section, not including any appended data in the overlay.\n    if (certTableAddress > 0) {\n        stream.moveTo(certTableAddress + certTableSize);\n        return stream.carve();\n    }\n\n    // Move past Optional Header to Section Header\n    stream.moveForwardsBy(88);\n\n    // Move to final section header\n    stream.moveForwardsBy((numSections - 1) * 0x28);\n\n    // Get raw data info\n    stream.moveForwardsBy(16);\n    const rawDataSize = stream.readInt(4, \"le\");\n    const rawDataAddress = stream.readInt(4, \"le\");\n\n    // Move to end of final section\n    stream.moveTo(rawDataAddress + rawDataSize);\n\n    return stream.carve();\n}\n\n\n/**\n * PDF extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractPDF(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Find end-of-file marker (%%EOF)\n    stream.continueUntil([0x25, 0x25, 0x45, 0x4f, 0x46]);\n    stream.moveForwardsBy(5);\n    stream.consumeIf(0x0d);\n    stream.consumeIf(0x0a);\n\n    return stream.carve();\n}\n\n\n/**\n * ZIP extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractZIP(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Find End of central directory record\n    stream.continueUntil([0x50, 0x4b, 0x05, 0x06]);\n\n    // Get comment length and consume\n    stream.moveForwardsBy(20);\n    const commentLength = stream.readInt(2, \"le\");\n    stream.moveForwardsBy(commentLength);\n\n    return stream.carve();\n}\n\n\n/**\n * MACHO extractor\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractMACHO(bytes, offset) {\n\n    // Magic bytes.\n    const MHCIGAM64 = \"207250237254\";\n    const MHMAGIC64 = \"254237250207\";\n    const MHCIGAM = \"206250237254\";\n\n\n    /**\n     * Checks to see if the file is 64-bit.\n     *\n     * @param {string} magic\n     * @returns {bool}\n     */\n    function isMagic64(magic) {\n        return magic === MHCIGAM64 || magic === MHMAGIC64;\n    }\n\n\n    /**\n     * Checks the endianness of the file.\n     *\n     * @param {string} magic\n     * @returns {bool}\n     */\n    function shouldSwapBytes(magic) {\n        return magic === MHCIGAM || magic === MHCIGAM64;\n    }\n\n\n    /**\n     * Jumps through segment information and calculates the sum of the segement sizes.\n     *\n     * @param {Stream} stream\n     * @param {number} offset\n     * @param {string} isSwap\n     * @param {number} ncmds\n     * @returns {number}\n     */\n    function dumpSegmentCommands(stream, offset, isSwap, ncmds) {\n        let total = 0;\n        const LCSEGEMENT64 = 0x19;\n        const LCSEGEMENT = 0x1;\n\n        for (let i = 0; i < ncmds; i++) {\n\n            // Move to start of segment.\n            stream.moveTo(offset);\n            const cmd = stream.readInt(4, isSwap);\n            if (cmd === LCSEGEMENT64) {\n\n                // Move to size of segment field.\n                stream.moveTo(offset + 48);\n\n                // Extract size of segement.\n                total += stream.readInt(8, isSwap);\n                stream.moveTo(offset + 4);\n\n                // Move to offset of next segment.\n                offset += stream.readInt(4, isSwap);\n            } else if (cmd === LCSEGEMENT) {\n                stream.moveTo(offset + 36);\n\n                // Extract size of segement.\n                total += stream.readInt(4, isSwap);\n                stream.moveTo(offset + 4);\n                offset += stream.readInt(4, isSwap);\n            }\n        }\n        return total;\n    }\n\n\n    /**\n     * Reads the number of command segments.\n     *\n     * @param {Stream} stream\n     * @param {bool} is64\n     * @param {string} isSwap\n     * @returns {number}\n     */\n    function dumpMachHeader(stream, is64, isSwap) {\n        let loadCommandsOffset = 28;\n        if (is64)\n            loadCommandsOffset += 4;\n\n        // Move to number of commands field.\n        stream.moveTo(16);\n        const ncmds = stream.readInt(4, isSwap);\n        return dumpSegmentCommands(stream, loadCommandsOffset, isSwap, ncmds);\n    }\n\n\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n    const magic = stream.getBytes(4).join(\"\");\n\n    // Move to the end of the final segment.\n    stream.moveTo(dumpMachHeader(stream, isMagic64(magic), shouldSwapBytes(magic) ? \"le\" : \"be\"));\n    return stream.carve();\n}\n\n\n/**\n * TAR extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractTAR(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n    while (stream.hasMore()) {\n\n        // Move to ustar identifier.\n        stream.moveForwardsBy(0x101);\n        if (stream.getBytes(5).join(\"\") !== [0x75, 0x73, 0x74, 0x61, 0x72].join(\"\")) {\n            // Reverse back to the end of the last section.\n            stream.moveBackwardsBy(0x106);\n            break;\n        }\n\n        // Move back to file size field.\n        stream.moveBackwardsBy(0x8a);\n        let fsize = 0;\n\n        // Read file size field.\n        stream.getBytes(11).forEach((element, index) => {\n            fsize += (element - 48).toString();\n        });\n\n        // Round number up from octet to nearest 512.\n        fsize = (Math.ceil(parseInt(fsize, 8) / 512) * 512);\n\n        // Move forwards to the end of that file.\n        stream.moveForwardsBy(fsize + 0x179);\n    }\n    stream.consumeWhile(0x00);\n    return stream.carve();\n}\n\n\n/**\n * PNG extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractPNG(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move past signature to first chunk\n    stream.moveForwardsBy(8);\n\n    let chunkSize = 0,\n        chunkType = \"\";\n\n    while (chunkType !== \"IEND\") {\n        chunkSize = stream.readInt(4, \"be\");\n        chunkType = stream.readString(4);\n\n        // Chunk data size + CRC checksum\n        stream.moveForwardsBy(chunkSize + 4);\n    }\n\n\n    return stream.carve();\n}\n\n\n/**\n * WEBP extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractWEBP(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to file size offset.\n    stream.moveForwardsBy(4);\n\n    // Read file size field.\n    const fileSize = stream.readInt(4, \"le\");\n\n    // Move to end of file.\n    // There is no need to minus 8 from the size as the size factors in the offset.\n    stream.moveForwardsBy(fileSize);\n\n    return stream.carve();\n}\n\n\n/**\n * BMP extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractBMP(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move past header\n    stream.moveForwardsBy(2);\n\n    // Read full file size\n    const bmpSize = stream.readInt(4, \"le\");\n\n    // Move to end of file (file size minus header and size field)\n    stream.moveForwardsBy(bmpSize - 6);\n\n    return stream.carve();\n}\n\n\n/**\n * ICO extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nfunction extractICO(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to number of files there are.\n    stream.moveTo(4);\n\n    // Read the number of files stored in the ICO\n    const numberFiles = stream.readInt(2, \"le\");\n\n    // Move forward to the last file header.\n    stream.moveForwardsBy(8 + ((numberFiles-1) * 16));\n    const fileSize = stream.readInt(4, \"le\");\n    const fileOffset = stream.readInt(4, \"le\");\n\n    // Move to the end of the last file.\n    stream.moveTo(fileOffset + fileSize);\n    return stream.carve();\n}\n\n\n/**\n * TARGA extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nfunction extractTARGA(bytes, offset) {\n    // Need all the bytes since we do not know how far up the image goes.\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes);\n    stream.moveTo(offset - 8);\n\n    // Read in the offsets of the possible areas.\n    const extensionOffset = stream.readInt(4, \"le\");\n    const developerOffset = stream.readInt(4, \"le\");\n\n    stream.moveBackwardsBy(8);\n\n    /**\n     * Moves backwards in the stream until it meet bytes that are the same as the amount of bytes moved.\n     *\n     * @param {number} sizeOfSize\n     * @param {number} maxSize\n     */\n    function moveBackwardsUntilSize(maxSize, sizeOfSize) {\n        for (let i = 0; i < maxSize; i++) {\n            stream.moveBackwardsBy(1);\n\n            // Read in sizeOfSize amount of bytes in.\n            const size = stream.readInt(sizeOfSize, \"le\") - 1;\n            stream.moveBackwardsBy(sizeOfSize);\n\n            // If the size matches.\n            if (size === i)\n                break;\n        }\n    }\n\n    /**\n     * Moves backwards in the stream until we meet bytes(when calculated) that are the same as the amount of bytes moved.\n     */\n    function moveBackwardsUntilImageSize() {\n        stream.moveBackwardsBy(5);\n\n        // The documentation said that 0x100000 was the largest the file could be.\n        for (let i = 0; i < 0x100000; i++) {\n\n            // (Height * Width * pixel depth in bits)/8\n            const total = (stream.readInt(2, \"le\") * stream.readInt(2, \"le\") * stream.readInt(1))/8;\n            if (total === i-1)\n                break;\n\n            stream.moveBackwardsBy(6);\n        }\n    }\n\n    if (extensionOffset || developerOffset) {\n        if (extensionOffset) {\n            // Size is stored in two bytes hence the maximum is 0xffff.\n            moveBackwardsUntilSize(0xffff, 2);\n\n            // Move to where we think the start of the file is.\n            stream.moveBackwardsBy(extensionOffset);\n        } else if (developerOffset) {\n            // Size is stored in 4 bytes hence the maxiumum is 0xffffffff.\n            moveBackwardsUntilSize(0xffffffff, 4);\n\n            // Size is stored in byte position 6 so have to move back.\n            stream.moveBackwardsBy(6);\n\n            // Move to where we think the start of the file is.\n            stream.moveBackwardsBy(developerOffset);\n        }\n    } else {\n        // Move backwards until size === number of bytes passed.\n        moveBackwardsUntilImageSize();\n\n        // Move backwards over the reaminder of the header + the 5 we borrowed in moveBackwardsUntilImageSize().\n        stream.moveBackwardsBy(0xc+5);\n    }\n\n    return stream.carve(stream.position, offset+0x12);\n}\n\n\n/**\n * WAV extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractWAV(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to file size field.\n    stream.moveTo(4);\n\n    // Move to file size.\n    stream.moveTo(stream.readInt(4, \"le\") + 8);\n\n    return stream.carve();\n}\n\n\n/**\n * MP3 extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractMP3(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Constants for flag byte.\n    const bitRateIndexes = [\"free\", 32000, 40000, 48000, 56000, 64000, 80000, 96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000, \"bad\"];\n\n    const samplingRateFrequencyIndex = [44100, 48000, 32000, \"reserved\"];\n\n    // ID3 tag, move over it.\n    if ((stream.getBytes(3).toString() === [0x49, 0x44, 0x33].toString())) {\n        stream.moveTo(6);\n        const tagSize = (stream.readInt(1) << 21) | (stream.readInt(1) << 14) | (stream.readInt(1) << 7) | stream.readInt(1);\n        stream.moveForwardsBy(tagSize);\n    } else {\n        stream.moveTo(0);\n    }\n\n    // Loop over all the frame headers in the file.\n    while (stream.hasMore()) {\n\n        // If it has an old TAG frame at the end of it, fixed size, 128 bytes.\n        if (stream.getBytes(3) === [0x54, 0x41, 0x47].toString()) {\n            stream.moveForwardsBy(125);\n            break;\n        }\n\n        // If not start of frame.\n        if (stream.getBytes(2).toString() !== [0xff, 0xfb].toString()) {\n            stream.moveBackwardsBy(2);\n            break;\n        }\n\n        // Read flag byte.\n        const flags = stream.readInt(1);\n\n        // Extract frame bit rate from flag byte.\n        const bitRate = bitRateIndexes[flags >> 4];\n\n        // Extract frame sample rate from flag byte.\n        const sampleRate = samplingRateFrequencyIndex[(flags & 0x0f) >> 2];\n\n        // Padding if the frame size is not a multiple of the bitrate.\n        const padding = (flags & 0x02) >> 1;\n\n        // Things that are either not standard or undocumented.\n        if (bitRate === \"free\" || bitRate === \"bad\" || sampleRate === \"reserved\") {\n            stream.moveBackwardsBy(1);\n            break;\n        }\n\n        // Formula: FrameLength = (144 * BitRate / SampleRate ) + Padding\n        const frameSize = Math.floor(((144 * bitRate) / sampleRate) + padding);\n\n        // If the next move goes past the end of the bytestream then extract the entire bytestream.\n        // We assume complete frames in the above formula because there is no field that suggests otherwise.\n        if ((stream.position + frameSize) > stream.length) {\n            stream.moveTo(stream.length);\n            break;\n        } else {\n            stream.moveForwardsBy(frameSize - 3);\n        }\n    }\n    return stream.carve();\n}\n\n\n/**\n * FLV extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractFLV(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move past signature, version and flags\n    stream.moveForwardsBy(5);\n\n    // Read header size\n    const headerSize = stream.readInt(4, \"be\");\n\n    // Skip through the rest of the header\n    stream.moveForwardsBy(headerSize - 9);\n\n    let tagSize = -11; // Fake size of previous tag header\n    while (stream.hasMore()) {\n        const prevTagSize = stream.readInt(4, \"be\");\n        const tagType = stream.readInt(1);\n\n        if ([8, 9, 18].indexOf(tagType) < 0) {\n            // This tag is not valid\n            stream.moveBackwardsBy(1);\n            break;\n        }\n\n        if (prevTagSize !== (tagSize + 11)) {\n            // Previous tag was not valid, reverse back over this header\n            // and the previous tag body and header\n            stream.moveBackwardsBy(tagSize + 11 + 5);\n            break;\n        }\n\n        tagSize = stream.readInt(3, \"be\");\n\n        // Move past the rest of the tag header and payload\n        stream.moveForwardsBy(7 + tagSize);\n    }\n\n    return stream.carve();\n}\n\n\n/**\n * RTF extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractRTF(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    let openTags = 0;\n\n    if (stream.readInt(1) !== 0x7b) { // {\n        throw new Error(\"Not a valid RTF file\");\n    } else {\n        openTags++;\n    }\n\n    while (openTags > 0 && stream.hasMore()) {\n        switch (stream.readInt(1)) {\n            case 0x7b: // {\n                openTags++;\n                break;\n            case 0x7d: // }\n                openTags--;\n                break;\n            case 0x5c: // \\\n                // Consume any more escapes and then skip over the next character\n                stream.consumeIf(0x5c);\n                stream.position++;\n                break;\n            default:\n                break;\n        }\n    }\n\n    return stream.carve();\n}\n\n\n/**\n * SQLITE extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractSQLITE(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Extract the size of the page.\n    stream.moveTo(16);\n    const pageSize = stream.readInt(2);\n\n    // Extract the number of pages.\n    stream.moveTo(28);\n    const numPages = stream.readInt(4);\n\n    // Move to the end of all the pages.\n    stream.moveTo(pageSize*numPages);\n\n    return stream.carve();\n}\n\n\n/**\n * PList (XML) extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractPListXML(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    let braceCount = 0;\n\n    // Continue to the first (<plist).\n    stream.continueUntil([0x3c, 0x70, 0x6c, 0x69, 0x73, 0x74]);\n    stream.moveForwardsBy(6);\n    braceCount++;\n\n    // While we have an unequal amount of braces.\n    while (braceCount > 0 && stream.hasMore()) {\n        if (stream.readInt(1) === 0x3c) {\n\n            // If we hit an <plist.\n            if (stream.getBytes(5).join(\"\") === [0x70, 0x6c, 0x69, 0x73, 0x74].join(\"\")) {\n                braceCount++;\n            } else {\n                stream.moveBackwardsBy(5);\n            }\n\n            // If we hit an </plist>.\n            if (stream.getBytes(7).join(\"\") === [0x2f, 0x70, 0x6c, 0x69, 0x73, 0x74, 0x3e].join(\"\")) {\n                braceCount--;\n            } else {\n                stream.moveBackwardsBy(7);\n            }\n        }\n    }\n    stream.consumeIf(0x0a);\n\n    return stream.carve();\n}\n\n\n/**\n * MacOS X Keychain Extactor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractMacOSXKeychain(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to size field.\n    stream.moveTo(0x14);\n\n    // Move forwards by size.\n    stream.moveForwardsBy(stream.readInt(4));\n\n    return stream.carve();\n}\n\n\n/**\n * OLE2 extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractOLE2(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n    const entries = [\n        [[0x52, 0x00, 0x6f, 0x00, 0x6f, 0x00, 0x74, 0x00, 0x20, 0x00, 0x45, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x72, 0x00, 0x79], 19, \"Root Entry\"],\n        [[0x57, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6b, 0x00, 0x62, 0x00, 0x6f, 0x00, 0x6f, 0x00, 0x6b], 15, \"Workbook\"],\n        [[0x43, 0x00, 0x75, 0x00, 0x72, 0x00, 0x72, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 0x55, 0x00, 0x73, 0x00, 0x65, 0x00, 0x72],  23,  \"Current User\"],\n        [[0x50, 0x00, 0x6f, 0x00, 0x77, 0x00, 0x65, 0x00, 0x72, 0x00, 0x50, 0x00, 0x6f, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x20, 0x00, 0x44, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x75, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74], 37, \"PowerPoint Document\"],\n        [[0x57, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x64, 0x00, 0x44, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x75, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74], 23, \"WordDocument\"],\n        [[0x44, 0x00, 0x61, 0x00, 0x74, 0x00, 0x61], 7, \"Data\"],\n        [[0x50, 0x00, 0x69, 0x00, 0x63, 0x00, 0x74, 0x00, 0x75, 0x00, 0x72, 0x00, 0x65, 0x00, 0x73], 15, \"Pictures\"],\n        [[0x31, 0x00, 0x54, 0x00, 0x61, 0x00, 0x62, 0x00, 0x6c, 0x00, 0x65], 11, \"1Table\"],\n        [[0x05, 0x00, 0x53, 0x00, 0x75, 0x00, 0x6d, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x72, 0x00, 0x79, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e], 37, \"SummaryInformation\"],\n        [[0x05, 0x00, 0x44, 0x00, 0x6f, 0x00, 0x63, 0x00, 0x75, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x53, 0x00, 0x75, 0x00, 0x6d, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x72, 0x00, 0x79, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x74, 0x00, 0x69, 0x00, 0x6f, 0x00, 0x6e], 53, \"DocumentSummaryInformation\"],\n        [[0x43, 0x00, 0x6f, 0x00, 0x6d, 0x00, 0x70, 0x00, 0x4f, 0x00, 0x62, 0x00, 0x6a], 13, \"Comp Obj\"],\n        [[0x01, 0x00], 2, \"Entry\"]\n    ];\n    let endianness = \"le\";\n\n    // Move to endianess field.\n    stream.moveForwardsBy(28);\n    if (stream.readInt(2, endianness) === 0xfffe)\n        endianness = \"be\";\n\n    // Calculate the size of the normal sectors.\n    const sizeOfSector = 2 ** stream.readInt(2, endianness);\n\n    // Move to root directory offset field.\n    stream.moveTo(48);\n\n    // Read root directory offset.\n    const rootStuff  = stream.readInt(4, endianness);\n\n    // Calculate root directory offset.\n    let total = 512 + (rootStuff * sizeOfSector);\n    stream.moveTo(total);\n\n    // While valid directory entries.\n    let found = true;\n    while (found) {\n        found = false;\n\n        // Attempt to determine what directory entry it is.\n        for (const element of entries) {\n\n            // If the byte pattern matches.\n            if (stream.getBytes(element[1]).join(\"\") === element[0].join(\"\")) {\n                stream.moveBackwardsBy(element[1]);\n                found = true;\n\n                // Move forwards by the size of the comp obj.\n                if (element[2] === \"Comp Obj\") {\n\n                    // The size of the Comp Obj entry - 128. Since we add 128 later.\n                    total += 128 * 6;\n                    stream.moveTo(total);\n                } else if (element[2] === \"Entry\") {\n\n                    // If there is an entry move backwards by 126 to then move forwards by 128. Hence a total displacement of 2.\n                    stream.moveBackwardsBy(126);\n                }\n                break;\n            }\n            stream.moveBackwardsBy(element[1]);\n        }\n\n        // If we have found a valid entry, move forwards by 128.\n        if (found) {\n\n            // Every entry is at least 128 in size, some are bigger which is dealt with by the above if statement.\n            total += 128;\n            stream.moveForwardsBy(128);\n        }\n    }\n\n    // Round up to a multiple of 512.\n    total = Math.ceil(total / 512) * 512;\n\n    stream.moveTo(total);\n    return stream.carve();\n}\n\n\n/**\n * GZIP extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractGZIP(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n\n    /* HEADER */\n\n    // Skip over signature and compression method\n    stream.moveForwardsBy(3);\n\n    // Read flags\n    const flags = stream.readInt(1);\n\n    // Skip over last modification time\n    stream.moveForwardsBy(4);\n\n    // Read compression flags\n    stream.readInt(1);\n\n    // Skip over OS\n    stream.moveForwardsBy(1);\n\n\n    /* OPTIONAL HEADERS */\n\n    // Extra fields\n    if (flags & 0x4) {\n        const extraFieldsSize = stream.readInt(2, \"le\");\n        stream.moveForwardsby(extraFieldsSize);\n    }\n\n    // Original filename\n    if (flags & 0x8) {\n        stream.continueUntil(0x00);\n        stream.moveForwardsBy(1);\n    }\n\n    // Comment\n    if (flags & 0x10) {\n        stream.continueUntil(0x00);\n        stream.moveForwardsBy(1);\n    }\n\n    // Checksum\n    if (flags & 0x2) {\n        stream.moveForwardsBy(2);\n    }\n\n\n    /* DEFLATE DATA */\n\n    parseDEFLATE(stream);\n\n\n    /* FOOTER */\n\n    // Skip over checksum and size of original uncompressed input\n    stream.moveForwardsBy(8);\n\n    return stream.carve();\n}\n\n\n/**\n * BZIP2 extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractBZIP2(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // The EOFs shifted between all possible combinations.\n    const lookingfor = [\n        [0x77, 0x24, 0x53, 0x85, 0x09],\n        [0xee, 0x48, 0xa7, 0x0a, 0x12],\n        [0xdc, 0x91, 0x4e, 0x14, 0x24],\n        [0xb9, 0x22, 0x9c, 0x28, 0x48],\n        [0x72, 0x45, 0x38, 0x50, 0x90],\n        [0xbb, 0x92, 0x29, 0xc2, 0x84],\n        [0x5d, 0xc9, 0x14, 0xe1, 0x42],\n        [0x2e, 0xe4, 0x8a, 0x70, 0xa1],\n        [0x17, 0x72, 0x45, 0x38, 0x50]\n    ];\n\n    for (let i = 0; i < lookingfor.length; i++) {\n        // Continue until an EOF.\n        stream.continueUntil(lookingfor[i]);\n        if (stream.getBytes(5).join(\"\") === lookingfor[i].join(\"\"))\n            break;\n\n        // Jump back to the start if invalid EOF.\n        stream.moveTo(0);\n    }\n    stream.moveForwardsBy(4);\n    return stream.carve();\n}\n\n\n/**\n * Zlib extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractZlib(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Skip over CMF\n    stream.moveForwardsBy(1);\n\n    // Read flags\n    const flags = stream.readInt(1);\n\n    // Skip over preset dictionary checksum\n    if (flags & 0x20) {\n        stream.moveForwardsBy(4);\n    }\n\n    // Parse DEFLATE stream\n    parseDEFLATE(stream);\n\n    // Skip over final checksum\n    stream.moveForwardsBy(4);\n\n    return stream.carve();\n}\n\n\n/**\n * XZ extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {string}\n */\nfunction extractXZ(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move forward to EOF marker\n    stream.continueUntil([0x00, 0x00, 0x00, 0x00, 0x04, 0x59, 0x5a]);\n\n    // Move over EOF marker\n    stream.moveForwardsBy(7);\n\n    return stream.carve();\n}\n\n\n/**\n * DEB extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n */\nfunction extractDEB(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move past !<arch>\n    stream.moveForwardsBy(8);\n    while (stream.hasMore()) {\n\n        // Move to size field.\n        stream.moveForwardsBy(48);\n        let fsize= \"\";\n\n        // Convert size to a usable number.\n        for (const elem of stream.getBytes(10)) {\n            fsize += String.fromCharCode(elem);\n        }\n        fsize = parseInt(fsize.trim(), 10);\n\n        // Move past `\\n\n        stream.moveForwardsBy(2);\n        stream.moveForwardsBy(fsize);\n    }\n    return stream.carve();\n}\n\n\n/**\n * ELF extractor.\n *\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nfunction extractELF(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Skip over magic number\n    stream.moveForwardsBy(4);\n\n    // Read architecture (x86 == 1, x64 == 2)\n    const x86 = stream.readInt(1) === 1;\n\n    // Read endianness (1 == little, 2 == big)\n    const endian = stream.readInt(1) === 1 ? \"le\" : \"be\";\n\n    // Skip over header values\n    stream.moveForwardsBy(x86 ? 26 : 34);\n\n    // Read section header table offset\n    const shoff = x86 ? stream.readInt(4, endian) : stream.readInt(8, endian);\n\n    // Skip over flags, header size and program header size and entries\n    stream.moveForwardsBy(10);\n\n    // Read section header table entry size\n    const shentsize = stream.readInt(2, endian);\n\n    // Read number of entries in the section header table\n    const shnum = stream.readInt(2, endian);\n\n    // Jump to section header table\n    stream.moveTo(shoff);\n\n    // Move past each section header\n    stream.moveForwardsBy(shentsize * shnum);\n\n    return stream.carve();\n}\n\n\n// Construct required Huffman Tables\nconst fixedLiteralTableLengths = new Array(288);\nfor (let i = 0; i < fixedLiteralTableLengths.length; i++) {\n    fixedLiteralTableLengths[i] =\n        (i <= 143) ? 8 :\n            (i <= 255) ? 9 :\n                (i <= 279) ? 7 :\n                    8;\n}\nconst fixedLiteralTable = buildHuffmanTable(fixedLiteralTableLengths);\nconst fixedDistanceTableLengths = new Array(30).fill(5);\nconst fixedDistanceTable = buildHuffmanTable(fixedDistanceTableLengths);\nconst huffmanOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n/**\n * Steps through a DEFLATE stream\n *\n * @param {Stream} stream\n */\nfunction parseDEFLATE(stream) {\n    // Parse DEFLATE data\n    let finalBlock = 0;\n\n    while (!finalBlock) {\n        // Read header\n        finalBlock = stream.readBits(1, \"le\");\n        const blockType = stream.readBits(2, \"le\");\n\n        if (blockType === 0) {\n            /* No compression */\n\n            // Consume the rest of the current byte\n            stream.moveForwardsBy(1);\n            // Read the block length value\n            const blockLength = stream.readInt(2, \"le\");\n            // Move to the end of this block\n            stream.moveForwardsBy(2 + blockLength);\n        } else if (blockType === 1) {\n            /* Fixed Huffman */\n\n            parseHuffmanBlock(stream, fixedLiteralTable, fixedDistanceTable);\n        } else if (blockType === 2) {\n            /* Dynamic Huffman */\n\n            // Read the number of liternal and length codes\n            const hlit = stream.readBits(5, \"le\") + 257;\n            // Read the number of distance codes\n            const hdist = stream.readBits(5, \"le\") + 1;\n            // Read the number of code lengths\n            const hclen = stream.readBits(4, \"le\") + 4;\n\n            // Parse code lengths\n            const codeLengths = new Uint8Array(huffmanOrder.length);\n            for (let i = 0; i < hclen; i++) {\n                codeLengths[huffmanOrder[i]] = stream.readBits(3, \"le\");\n            }\n\n            // Parse length table\n            const codeLengthsTable = buildHuffmanTable(codeLengths);\n            const lengthTable = new Uint8Array(hlit + hdist);\n\n            let code, repeat, prev;\n            for (let i = 0; i < hlit + hdist;) {\n                code = readHuffmanCode(stream, codeLengthsTable);\n                switch (code) {\n                    case 16:\n                        repeat = 3 + stream.readBits(2, \"le\");\n                        while (repeat--) lengthTable[i++] = prev;\n                        break;\n                    case 17:\n                        repeat = 3 + stream.readBits(3, \"le\");\n                        while (repeat--) lengthTable[i++] = 0;\n                        prev = 0;\n                        break;\n                    case 18:\n                        repeat = 11 + stream.readBits(7, \"le\");\n                        while (repeat--) lengthTable[i++] = 0;\n                        prev = 0;\n                        break;\n                    default:\n                        lengthTable[i++] = code;\n                        prev = code;\n                        break;\n                }\n            }\n\n            const dynamicLiteralTable = buildHuffmanTable(lengthTable.subarray(0, hlit));\n            const dynamicDistanceTable = buildHuffmanTable(lengthTable.subarray(hlit));\n\n            parseHuffmanBlock(stream, dynamicLiteralTable, dynamicDistanceTable);\n        } else {\n            throw new Error(`Invalid block type while parsing DEFLATE stream at pos ${stream.position}`);\n        }\n    }\n\n    // Consume final byte if it has not been fully consumed yet\n    if (stream.bitPos > 0)\n        stream.moveForwardsBy(1);\n}\n\n\n// Static length tables\nconst lengthExtraTable = [\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0\n];\nconst distanceExtraTable = [\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13\n];\n\n/**\n * Parses a Huffman Block given the literal and distance tables\n *\n * @param {Stream} stream\n * @param {Uint32Array} litTab\n * @param {Uint32Array} distTab\n */\nfunction parseHuffmanBlock(stream, litTab, distTab) {\n    let code;\n    let loops = 0;\n    while ((code = readHuffmanCode(stream, litTab))) {\n        // console.log(\"Code: \" + code + \" (\" + Utils.chr(code) + \") \" + Utils.bin(code));\n\n        // End of block\n        if (code === 256) break;\n\n        // Detect probably infinite loops\n        if (++loops > 10000)\n            throw new Error(\"Caught in probable infinite loop while parsing Huffman Block\");\n\n        // Literal\n        if (code < 256) continue;\n\n        // Length code\n        stream.readBits(lengthExtraTable[code - 257], \"le\");\n\n        // Dist code\n        code = readHuffmanCode(stream, distTab);\n        stream.readBits(distanceExtraTable[code], \"le\");\n    }\n}\n\n\n/**\n * Builds a Huffman table given the relevant code lengths\n *\n * @param {Array} lengths\n * @returns {Array} result\n * @returns {Uint32Array} result.table\n * @returns {number} result.maxCodeLength\n * @returns {number} result.minCodeLength\n */\nfunction buildHuffmanTable(lengths) {\n    const maxCodeLength = Math.max.apply(Math, lengths);\n    const minCodeLength = Math.min.apply(Math, lengths);\n    const size = 1 << maxCodeLength;\n    const table = new Uint32Array(size);\n\n    for (let bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\n        for (let i = 0; i < lengths.length; i++) {\n            if (lengths[i] === bitLength) {\n                let reversed, rtemp, j;\n                for (reversed = 0, rtemp = code, j = 0; j < bitLength; j++) {\n                    reversed = (reversed << 1) | (rtemp & 1);\n                    rtemp >>= 1;\n                }\n\n                const value = (bitLength << 16) | i;\n                for (let j = reversed; j < size; j += skip) {\n                    table[j] = value;\n                }\n\n                code++;\n            }\n        }\n\n        bitLength++;\n        code <<= 1;\n        skip <<= 1;\n    }\n\n    return [table, maxCodeLength, minCodeLength];\n}\n\n\n/**\n * Reads the next Huffman code from the stream, given the relevant code table\n *\n * @param {Stream} stream\n * @param {Uint32Array} table\n * @returns {number}\n */\nfunction readHuffmanCode(stream, table) {\n    const [codeTable, maxCodeLength] = table;\n\n    // Read max length\n    const bitsBuf = stream.readBits(maxCodeLength, \"le\");\n    const codeWithLength = codeTable[bitsBuf & ((1 << maxCodeLength) - 1)];\n    const codeLength = codeWithLength >>> 16;\n\n    if (codeLength > maxCodeLength) {\n        throw new Error(`Invalid Huffman Code length while parsing DEFLATE block at pos ${stream.position}: ${codeLength}`);\n    }\n\n    stream.moveBackwardsByBits(maxCodeLength - codeLength);\n\n    return codeWithLength & 0xffff;\n}\n\n\n/**\n * EVTX extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractEVTX(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to first ELFCHNK.\n    stream.moveTo(0x28);\n    const total = stream.readInt(4, \"le\") - 0x2c;\n    stream.moveForwardsBy(total);\n\n    while (stream.hasMore()) {\n        // Loop through ELFCHNKs.\n        if (stream.getBytes(7).join(\"\") !== [0x45, 0x6c, 0x66, 0x43, 0x68, 0x6e, 0x6b].join(\"\"))\n            break;\n        stream.moveForwardsBy(0xfff9);\n    }\n    stream.consumeWhile(0x00);\n    return stream.carve();\n}\n\n\n/**\n * EVT extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractEVT(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Extract offset of EOF.\n    stream.moveTo(0x14);\n    const eofOffset = stream.readInt(4, \"le\");\n    stream.moveTo(eofOffset);\n\n    // Extract the size of the EOF.\n    const eofSize = stream.readInt(4, \"le\");\n\n    // Move past EOF.\n    stream.moveForwardsBy(eofSize-4);\n    return stream.carve();\n}\n\n\n/**\n * DMP extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractDMP(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to fileSize field.\n    stream.moveTo(0x70);\n\n    // Multiply number of pages by page size. Plus 1 since the header is a page.\n    stream.moveTo((stream.readInt(4, \"le\") + 1) * 0x1000);\n\n    return stream.carve();\n}\n\n\n/**\n * PF extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractPF(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to file size.\n    stream.moveTo(12);\n    stream.moveTo(stream.readInt(4, \"be\"));\n\n    return stream.carve();\n}\n\n\n/**\n * PF (Win 10) extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractPFWin10(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Read in file size.\n    stream.moveTo(stream.readInt(4, \"be\"));\n\n    return stream.carve();\n}\n\n\n/**\n * LNK extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractLNK(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Move to file size field.\n    stream.moveTo(0x34);\n    stream.moveTo(stream.readInt(4, \"le\"));\n\n    return stream.carve();\n}\n\n\n/**\n * LZOP extractor.\n *\n * @param {Uint8Array} bytes\n * @param {Number} offset\n * @returns {Uint8Array}\n */\nfunction extractLZOP(bytes, offset) {\n    const stream = new _Stream_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes.slice(offset));\n\n    // Flag bits.\n    const F_ADLER32_D = 0x00000001;\n    const F_ADLER32_C = 0x00000002;\n    const F_CRC32_D = 0x00000100;\n    const F_CRC32_C = 0x00000200;\n    const F_H_FILTER = 0x00000800;\n    const F_H_EXTRA_FIELD = 0x00000040;\n\n    let numCheckSumC = 0, numCheckSumD = 0;\n\n    // Move over magic bytes.\n    stream.moveForwardsBy(9);\n\n    const version = stream.readInt(2, \"be\");\n\n    // Move to flag register offset.\n    stream.moveForwardsBy(6);\n    const flags = stream.readInt(4, \"be\");\n\n    if (version & F_H_FILTER)\n        stream.moveForwardsBy(4);\n\n    if (flags & F_ADLER32_C)\n        numCheckSumC++;\n\n    if (flags & F_CRC32_C)\n        numCheckSumC++;\n\n    if (flags & F_ADLER32_D)\n        numCheckSumD++;\n\n    if (flags & F_CRC32_D)\n        numCheckSumD++;\n\n    // Move over the mode, mtime_low\n    stream.moveForwardsBy(8);\n\n    if (version >= 0x0940)\n        stream.moveForwardsBy(4);\n\n    const fnameSize = stream.readInt(1, \"be\");\n\n    // Move forwards by size of file name and the following 4 byte checksum.\n    stream.moveForwardsBy(fnameSize);\n\n    if (flags & F_H_EXTRA_FIELD) {\n        const extraSize = stream.readInt(4, \"be\");\n        stream.moveForwardsBy(extraSize);\n    }\n\n    // Move past checksum.\n    stream.moveForwardsBy(4);\n\n    while (stream.hasMore()) {\n        const uncompSize = stream.readInt(4, \"be\");\n\n        // If data has no length, break.\n        if (uncompSize === 0)\n            break;\n\n        const compSize = stream.readInt(4, \"be\");\n\n        const numCheckSumSkip = (uncompSize === compSize) ? numCheckSumD : numCheckSumD + numCheckSumC;\n\n        // skip forwards by compressed data size and the size of the checksum(s).\n        stream.moveForwardsBy(compSize + (numCheckSumSkip * 4));\n    }\n    return stream.carve();\n\n}\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/FileSignatures.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/FileType.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/FileType.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   detectFileType: () => (/* binding */ detectFileType),\n/* harmony export */   extractFile: () => (/* binding */ extractFile),\n/* harmony export */   isImage: () => (/* binding */ isImage),\n/* harmony export */   isType: () => (/* binding */ isType),\n/* harmony export */   scanForFileTypes: () => (/* binding */ scanForFileTypes)\n/* harmony export */ });\n/* harmony import */ var _FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FileSignatures.mjs */ \"./node_modules/cyberchef/src/core/lib/FileSignatures.mjs\");\n/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils.mjs */ \"./node_modules/cyberchef/src/core/Utils.mjs\");\n/**\n * File type functions\n *\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2018\n * @license Apache-2.0\n *\n */\n\n\n\n\n/**\n * Checks whether a signature matches a buffer.\n *\n * @param {Object|Object[]} sig - A dictionary of offsets with values assigned to them.\n *   These values can be numbers for static checks, arrays of potential valid matches,\n *   or bespoke functions to check the validity of the buffer value at that offset.\n * @param {Uint8Array} buf\n * @param {number} [offset=0] Where in the buffer to start searching from\n * @returns {boolean}\n */\nfunction signatureMatches(sig, buf, offset=0) {\n    // Using a length check seems to be more performant than `sig instanceof Array`\n    if (sig.length) {\n        // sig is an Array - return true if any of them match\n        // The following `reduce` method is nice, but performance matters here, so we\n        // opt for a faster, if less elegant, for loop.\n        // return sig.reduce((acc, s) => acc || bytesMatch(s, buf, offset), false);\n        for (let i = 0; i < sig.length; i++) {\n            if (bytesMatch(sig[i], buf, offset)) return true;\n        }\n        return false;\n    } else {\n        return bytesMatch(sig, buf, offset);\n    }\n}\n\n\n/**\n * Checks whether a set of bytes match the given buffer.\n *\n * @param {Object} sig - A dictionary of offsets with values assigned to them.\n *   These values can be numbers for static checks, arrays of potential valid matches,\n *   or bespoke functions to check the validity of the buffer value at that offset.\n * @param {Uint8Array} buf\n * @param {number} [offset=0] Where in the buffer to start searching from\n * @returns {boolean}\n */\nfunction bytesMatch(sig, buf, offset=0) {\n    for (const sigoffset in sig) {\n        const pos = parseInt(sigoffset, 10) + offset;\n        switch (typeof sig[sigoffset]) {\n            case \"number\": // Static check\n                if (buf[pos] !== sig[sigoffset])\n                    return false;\n                break;\n            case \"object\": // Array of options\n                if (sig[sigoffset].indexOf(buf[pos]) < 0)\n                    return false;\n                break;\n            case \"function\": // More complex calculation\n                if (!sig[sigoffset](buf[pos]))\n                    return false;\n                break;\n            default:\n                throw new Error(`Unrecognised signature type at offset ${sigoffset}`);\n        }\n    }\n    return true;\n}\n\n\n/**\n * Given a buffer, detects magic byte sequences at specific positions and returns the\n * extension and mime type.\n *\n * @param {Uint8Array|ArrayBuffer} buf\n * @param {string[]} [categories=All] - Which categories of file to look for\n * @returns {Object[]} types\n * @returns {string} type.name - Name of file type\n * @returns {string} type.ext - File extension\n * @returns {string} type.mime - Mime type\n * @returns {string} [type.desc] - Description\n */\nfunction detectFileType(buf, categories=Object.keys(_FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__.FILE_SIGNATURES)) {\n    if (buf instanceof ArrayBuffer) {\n        buf = new Uint8Array(buf);\n    }\n\n    if (!(buf && buf.length > 1)) {\n        return [];\n    }\n\n    const matchingFiles = [];\n    const signatures = {};\n\n    for (const cat in _FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__.FILE_SIGNATURES) {\n        if (categories.includes(cat)) {\n            signatures[cat] = _FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__.FILE_SIGNATURES[cat];\n        }\n    }\n\n    for (const cat in signatures) {\n        const category = signatures[cat];\n\n        category.forEach(filetype => {\n            if (signatureMatches(filetype.signature, buf)) {\n                matchingFiles.push(filetype);\n            }\n        });\n    }\n    return matchingFiles;\n}\n\n\n/**\n * Given a buffer, searches for magic byte sequences at all possible positions and returns\n * the extensions and mime types.\n *\n * @param {Uint8Array} buf\n * @param {string[]} [categories=All] - Which categories of file to look for\n * @returns {Object[]} foundFiles\n * @returns {number} foundFiles.offset - The position in the buffer at which this file was found\n * @returns {Object} foundFiles.fileDetails\n * @returns {string} foundFiles.fileDetails.name - Name of file type\n * @returns {string} foundFiles.fileDetails.ext - File extension\n * @returns {string} foundFiles.fileDetails.mime - Mime type\n * @returns {string} [foundFiles.fileDetails.desc] - Description\n */\nfunction scanForFileTypes(buf, categories=Object.keys(_FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__.FILE_SIGNATURES)) {\n    if (!(buf && buf.length > 1)) {\n        return [];\n    }\n\n    const foundFiles = [];\n    const signatures = {};\n\n    for (const cat in _FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__.FILE_SIGNATURES) {\n        if (categories.includes(cat)) {\n            signatures[cat] = _FileSignatures_mjs__WEBPACK_IMPORTED_MODULE_0__.FILE_SIGNATURES[cat];\n        }\n    }\n\n    for (const cat in signatures) {\n        const category = signatures[cat];\n\n        for (let i = 0; i < category.length; i++) {\n            const filetype = category[i];\n            const sigs = filetype.signature.length ? filetype.signature : [filetype.signature];\n\n            sigs.forEach(sig => {\n                let pos = 0;\n                while ((pos = locatePotentialSig(buf, sig, pos)) >= 0) {\n                    if (bytesMatch(sig, buf, pos)) {\n                        (0,_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__.sendStatusMessage)(`Found potential signature for ${filetype.name} at pos ${pos}`);\n                        foundFiles.push({\n                            offset: pos,\n                            fileDetails: filetype\n                        });\n                    }\n                    pos++;\n                }\n            });\n        }\n    }\n\n    // Return found files in order of increasing offset\n    return foundFiles.sort((a, b) => {\n        return a.offset - b.offset;\n    });\n}\n\n\n/**\n * Fastcheck function to quickly scan the buffer for the first byte in a signature.\n *\n * @param {Uint8Array} buf - The buffer to search\n * @param {Object} sig - A single signature object (Not an array of signatures)\n * @param {number} offset - Where to start search from\n * @returns {number} The position of the match or -1 if one cannot be found.\n */\nfunction locatePotentialSig(buf, sig, offset) {\n    // Find values for first key and value in sig\n    const k = parseInt(Object.keys(sig)[0], 10);\n    const v = Object.values(sig)[0];\n    switch (typeof v) {\n        case \"number\":\n            return buf.indexOf(v, offset + k) - k;\n        case \"object\":\n            for (let i = offset + k; i < buf.length; i++) {\n                if (v.indexOf(buf[i]) >= 0) return i - k;\n            }\n            return -1;\n        case \"function\":\n            for (let i = offset + k; i < buf.length; i++) {\n                if (v(buf[i])) return i - k;\n            }\n            return -1;\n        default:\n            throw new Error(\"Unrecognised signature type\");\n    }\n}\n\n\n/**\n * Detects whether the given buffer is a file of the type specified.\n *\n * @param {string|RegExp} type\n * @param {Uint8Array|ArrayBuffer} buf\n * @returns {string|false} The mime type or false if the type does not match\n */\nfunction isType(type, buf) {\n    const types = detectFileType(buf);\n\n    if (!types.length) return false;\n\n    if (typeof type === \"string\") {\n        return types.reduce((acc, t) => {\n            const mime = t.mime.startsWith(type) ? t.mime : false;\n            return acc || mime;\n        }, false);\n    } else if (type instanceof RegExp) {\n        return types.reduce((acc, t) => {\n            const mime = type.test(t.mime) ? t.mime : false;\n            return acc || mime;\n        }, false);\n    } else {\n        throw new Error(\"Invalid type input.\");\n    }\n}\n\n\n/**\n * Detects whether the given buffer contains an image file.\n *\n * @param {Uint8Array|ArrayBuffer} buf\n * @returns {string|false} The mime type or false if the type does not match\n */\nfunction isImage(buf) {\n    return isType(\"image\", buf);\n}\n\n\n/**\n * Attempts to extract a file from a data stream given its offset and extractor function.\n *\n * @param {Uint8Array} bytes\n * @param {Object} fileDetail\n * @param {string} fileDetail.mime\n * @param {string} fileDetail.extension\n * @param {Function} fileDetail.extractor\n * @param {number} offset\n * @returns {File}\n */\nfunction extractFile(bytes, fileDetail, offset) {\n    if (fileDetail.extractor) {\n        (0,_Utils_mjs__WEBPACK_IMPORTED_MODULE_1__.sendStatusMessage)(`Attempting to extract ${fileDetail.name} at pos ${offset}...`);\n        const fileData = fileDetail.extractor(bytes, offset);\n        const ext = fileDetail.extension.split(\",\")[0];\n        return new File([fileData], `extracted_at_0x${offset.toString(16)}.${ext}`, {\n            type: fileDetail.mime\n        });\n    }\n\n    throw new Error(`No extraction algorithm available for \"${fileDetail.mime}\" files`);\n}\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/FileType.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/Hex.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/Hex.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FROM_HEX_DELIM_OPTIONS: () => (/* binding */ FROM_HEX_DELIM_OPTIONS),\n/* harmony export */   TO_HEX_DELIM_OPTIONS: () => (/* binding */ TO_HEX_DELIM_OPTIONS),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toHexFast: () => (/* binding */ toHexFast)\n/* harmony export */ });\n/* harmony import */ var _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Utils.mjs */ \"./node_modules/cyberchef/src/core/Utils.mjs\");\n/* harmony import */ var _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/OperationError.mjs */ \"./node_modules/cyberchef/src/core/errors/OperationError.mjs\");\n/**\n * Hexadecimal functions.\n *\n * @author n1474335 [n1474335@gmail.com]\n * @copyright Crown Copyright 2016\n * @license Apache-2.0\n */\n\n\n\n\n\n/**\n * Convert a byte array into a hex string.\n *\n * @param {byteArray|Uint8Array|ArrayBuffer} data\n * @param {string} [delim=\" \"]\n * @param {number} [padding=2]\n * @returns {string}\n *\n * @example\n * // returns \"0a 14 1e\"\n * toHex([10,20,30]);\n *\n * // returns \"0a:14:1e\"\n * toHex([10,20,30], \":\");\n *\n * // returns \"0x0a,0x14,0x1e\"\n * toHex([10,20,30], \"0x\", 2, \",\")\n */\nfunction toHex(data, delim=\" \", padding=2, extraDelim=\"\", lineSize=0) {\n    if (!data) return \"\";\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n\n    let output = \"\";\n    const prepend = (delim === \"0x\" || delim === \"\\\\x\");\n\n    for (let i = 0; i < data.length; i++) {\n        const hex = data[i].toString(16).padStart(padding, \"0\");\n        output += prepend ? delim + hex : hex + delim;\n\n        if (extraDelim) {\n            output += extraDelim;\n        }\n        // Add LF after each lineSize amount of bytes but not at the end\n        if ((i !== data.length - 1) && ((i + 1) % lineSize === 0)) {\n            output += \"\\n\";\n        }\n    }\n\n    // Remove the extraDelim at the end (if there is one)\n    // and remove the delim at the end, but if it's prepended there's nothing to remove\n    const rTruncLen = extraDelim.length + (prepend ? 0 : delim.length);\n    if (rTruncLen) {\n        // If rTruncLen === 0 then output.slice(0,0) will be returned, which is nothing\n        return output.slice(0, -rTruncLen);\n    } else {\n        return output;\n    }\n}\n\n\n/**\n * Convert a byte array into a hex string as efficiently as possible with no options.\n *\n * @param {byteArray|Uint8Array|ArrayBuffer} data\n * @returns {string}\n *\n * @example\n * // returns \"0a141e\"\n * toHex([10,20,30]);\n */\nfunction toHexFast(data) {\n    if (!data) return \"\";\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data);\n\n    const output = [];\n\n    for (let i = 0; i < data.length; i++) {\n        output.push((data[i] >>> 4).toString(16));\n        output.push((data[i] & 0x0f).toString(16));\n    }\n\n    return output.join(\"\");\n}\n\n\n/**\n * Convert a hex string into a byte array.\n *\n * @param {string} data\n * @param {string} [delim]\n * @param {number} [byteLen=2]\n * @returns {byteArray}\n *\n * @example\n * // returns [10,20,30]\n * fromHex(\"0a 14 1e\");\n *\n * // returns [10,20,30]\n * fromHex(\"0a:14:1e\", \"Colon\");\n */\nfunction fromHex(data, delim=\"Auto\", byteLen=2) {\n    if (byteLen < 1 || Math.round(byteLen) !== byteLen)\n        throw new _errors_OperationError_mjs__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\"Byte length must be a positive integer\");\n\n    if (delim !== \"None\") {\n        const delimRegex = delim === \"Auto\" ? /[^a-f\\d]|0x/gi : _Utils_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].regexRep(delim);\n        data = data.split(delimRegex);\n    } else {\n        data = [data];\n    }\n\n    const output = [];\n    for (let i = 0; i < data.length; i++) {\n        for (let j = 0; j < data[i].length; j += byteLen) {\n            output.push(parseInt(data[i].substr(j, byteLen), 16));\n        }\n    }\n    return output;\n}\n\n\n/**\n * To Hexadecimal delimiters.\n */\nconst TO_HEX_DELIM_OPTIONS = [\"Space\", \"Percent\", \"Comma\", \"Semi-colon\", \"Colon\", \"Line feed\", \"CRLF\", \"0x\", \"0x with comma\", \"\\\\x\", \"None\"];\n\n\n/**\n * From Hexadecimal delimiters.\n */\nconst FROM_HEX_DELIM_OPTIONS = [\"Auto\"].concat(TO_HEX_DELIM_OPTIONS);\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/Hex.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/core/lib/Stream.mjs":
/*!********************************************************!*\
  !*** ./node_modules/cyberchef/src/core/lib/Stream.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Stream)\n/* harmony export */ });\n/**\n * Stream class for parsing binary protocols.\n *\n * @author n1474335 [n1474335@gmail.com]\n * @author tlwr [toby@toby.codes]\n * @copyright Crown Copyright 2018\n * @license Apache-2.0\n *\n */\n\n/**\n * A Stream can be used to traverse a binary blob, interpreting sections of it\n * as various data types.\n */\nclass Stream {\n\n    /**\n     * Stream constructor.\n     *\n     * @param {Uint8Array} input\n     * @param {number} pos\n     * @param {number} bitPos\n     */\n    constructor(input, pos=0, bitPos=0) {\n        this.bytes = input;\n        this.length = this.bytes.length;\n        this.position = pos;\n        this.bitPos = bitPos;\n    }\n\n    /**\n     * Clone this Stream returning a new identical Stream.\n     *\n     * @returns {Stream}\n     */\n    clone() {\n        return new Stream(this.bytes, this.position, this.bitPos);\n    }\n\n    /**\n     * Get a number of bytes from the current position, or all remaining bytes.\n     *\n     * @param {number} [numBytes=null]\n     * @returns {Uint8Array}\n     */\n    getBytes(numBytes=null) {\n        if (this.position > this.length) return undefined;\n\n        const newPosition = numBytes !== null ?\n            this.position + numBytes :\n            this.length;\n        const bytes = this.bytes.slice(this.position, newPosition);\n        this.position = newPosition;\n        this.bitPos = 0;\n        return bytes;\n    }\n\n    /**\n     * Interpret the following bytes as a string, stopping at the next null byte or\n     * the supplied limit.\n     *\n     * @param {number} [numBytes=-1]\n     * @returns {string}\n     */\n    readString(numBytes=-1) {\n        if (this.position > this.length) return undefined;\n\n        if (numBytes === -1) numBytes = this.length - this.position;\n\n        let result = \"\";\n        for (let i = this.position; i < this.position + numBytes; i++) {\n            const currentByte = this.bytes[i];\n            if (currentByte === 0) break;\n            result += String.fromCharCode(currentByte);\n        }\n        this.position += numBytes;\n        this.bitPos = 0;\n        return result;\n    }\n\n    /**\n     * Interpret the following bytes as an integer in big or little endian.\n     *\n     * @param {number} numBytes\n     * @param {string} [endianness=\"be\"]\n     * @returns {number}\n     */\n    readInt(numBytes, endianness=\"be\") {\n        if (this.position > this.length) return undefined;\n\n        let val = 0;\n        if (endianness === \"be\") {\n            for (let i = this.position; i < this.position + numBytes; i++) {\n                val = val << 8;\n                val |= this.bytes[i];\n            }\n        } else {\n            for (let i = this.position + numBytes - 1; i >= this.position; i--) {\n                val = val << 8;\n                val |= this.bytes[i];\n            }\n        }\n        this.position += numBytes;\n        this.bitPos = 0;\n        return val;\n    }\n\n    /**\n     * Reads a number of bits from the buffer in big or little endian.\n     *\n     * @param {number} numBits\n     * @param {string} [endianness=\"be\"]\n     * @returns {number}\n     */\n    readBits(numBits, endianness=\"be\") {\n        if (this.position > this.length) return undefined;\n\n        let bitBuf = 0,\n            bitBufLen = 0;\n\n        // Add remaining bits from current byte\n        bitBuf = this.bytes[this.position++] & bitMask(this.bitPos);\n        if (endianness !== \"be\") bitBuf >>>= this.bitPos;\n        bitBufLen = 8 - this.bitPos;\n        this.bitPos = 0;\n\n        // Not enough bits yet\n        while (bitBufLen < numBits) {\n            if (endianness === \"be\")\n                bitBuf = (bitBuf << bitBufLen) | this.bytes[this.position++];\n            else\n                bitBuf |= this.bytes[this.position++] << bitBufLen;\n            bitBufLen += 8;\n        }\n\n        // Reverse back to numBits\n        if (bitBufLen > numBits) {\n            const excess = bitBufLen - numBits;\n            if (endianness === \"be\")\n                bitBuf >>>= excess;\n            else\n                bitBuf &= (1 << numBits) - 1;\n            bitBufLen -= excess;\n            this.position--;\n            this.bitPos = 8 - excess;\n        }\n\n        return bitBuf;\n\n        /**\n         * Calculates the bit mask based on the current bit position.\n         *\n         * @param {number} bitPos\n         * @returns {number} The bit mask\n         */\n        function bitMask(bitPos) {\n            return endianness === \"be\" ?\n                (1 << (8 - bitPos)) - 1 :\n                256 - (1 << bitPos);\n        }\n    }\n\n    /**\n     * Consume the stream until we reach the specified byte or sequence of bytes.\n     *\n     * @param {number|List<number>} val\n     */\n    continueUntil(val) {\n        if (this.position > this.length) return;\n\n        this.bitPos = 0;\n\n        if (typeof val === \"number\") {\n            while (++this.position < this.length && this.bytes[this.position] !== val) {\n                continue;\n            }\n            return;\n        }\n\n        // val is an array\n\n        /**\n         * Builds the skip forward table from the value to be searched.\n         *\n         * @param {Uint8Array} val\n         * @param {Number} len\n         * @returns {Uint8Array}\n         */\n        function preprocess(val, len) {\n            const skiptable = new Array();\n            val.forEach((element, index) => {\n                skiptable[element] = len - index;\n            });\n            return skiptable;\n        }\n\n        const length = val.length;\n        const initial = val[length-1];\n        this.position = length;\n\n        // Get the skip table.\n        const skiptable = preprocess(val, length);\n        let found;\n\n        while (this.position < this.length) {\n            // Until we hit the final element of val in the stream.\n            while ((this.position < this.length) && (this.bytes[this.position++] !== initial));\n\n            found = true;\n\n            // Loop through the elements comparing them to val.\n            for (let x = length-1; x >= 0; x--) {\n                if (this.bytes[this.position - length + x] !== val[x]) {\n                    found = false;\n\n                    // If element is not equal to val's element then jump forward by the correct amount.\n                    this.position += skiptable[val[x]];\n                    break;\n                }\n            }\n            if (found) {\n                this.position -= length;\n                break;\n            }\n        }\n    }\n\n\n    /**\n     * Consume bytes if they match the supplied value.\n     *\n     * @param {Number} val\n     */\n    consumeWhile(val) {\n        while (this.position < this.length) {\n            if (this.bytes[this.position] !== val) {\n                break;\n            }\n            this.position++;\n        }\n        this.bitPos = 0;\n    }\n\n    /**\n     * Consume the next byte if it matches the supplied value.\n     *\n     * @param {number} val\n     */\n    consumeIf(val) {\n        if (this.bytes[this.position] === val) {\n            this.position++;\n            this.bitPos = 0;\n        }\n    }\n\n    /**\n     * Move forwards through the stream by the specified number of bytes.\n     *\n     * @param {number} numBytes\n     */\n    moveForwardsBy(numBytes) {\n        const pos = this.position + numBytes;\n        if (pos < 0 || pos > this.length)\n            throw new Error(\"Cannot move to position \" + pos + \" in stream. Out of bounds.\");\n        this.position = pos;\n        this.bitPos = 0;\n    }\n\n    /**\n     * Move backwards through the stream by the specified number of bytes.\n     *\n     * @param {number} numBytes\n     */\n    moveBackwardsBy(numBytes) {\n        const pos = this.position - numBytes;\n        if (pos < 0 || pos > this.length)\n            throw new Error(\"Cannot move to position \" + pos + \" in stream. Out of bounds.\");\n        this.position = pos;\n        this.bitPos = 0;\n    }\n\n    /**\n     * Move backwards through the strem by the specified number of bits.\n     *\n     * @param {number} numBits\n     */\n    moveBackwardsByBits(numBits) {\n        if (numBits <= this.bitPos) {\n            this.bitPos -= numBits;\n        } else {\n            if (this.bitPos > 0) {\n                numBits -= this.bitPos;\n                this.bitPos = 0;\n            }\n\n            while (numBits > 0) {\n                this.moveBackwardsBy(1);\n                this.bitPos = 8;\n                this.moveBackwardsByBits(numBits);\n                numBits -= 8;\n            }\n        }\n    }\n\n    /**\n     * Move to a specified position in the stream.\n     *\n     * @param {number} pos\n     */\n    moveTo(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new Error(\"Cannot move to position \" + pos + \" in stream. Out of bounds.\");\n        this.position = pos;\n        this.bitPos = 0;\n    }\n\n    /**\n     * Returns true if there are more bytes left in the stream.\n     *\n     * @returns {boolean}\n     */\n    hasMore() {\n        return this.position < this.length;\n    }\n\n    /**\n     * Returns a slice of the stream up to the current position.\n     *\n     * @param {number} [start=0]\n     * @param {number} [finish=this.position]\n     * @returns {Uint8Array}\n     */\n    carve(start=0, finish=this.position) {\n        if (this.bitPos > 0) finish++;\n        return this.bytes.slice(start, finish);\n    }\n\n}\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/core/lib/Stream.mjs?\n}");

/***/ }),

/***/ "./node_modules/cyberchef/src/node/File.mjs":
/*!**************************************************!*\
  !*** ./node_modules/cyberchef/src/node/File.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_lib_FileType_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/lib/FileType.mjs */ \"./node_modules/cyberchef/src/core/lib/FileType.mjs\");\n/**\n * @author d98762625 [d98762625@gmail.com]\n * @copyright Crown Copyright 2019\n * @license Apache-2.0\n */\n\n\n\n\n/**\n * FileShim\n *\n * Create a class that behaves like the File object in the Browser so that\n * operations that use the File object still work.\n *\n * File doesn't write to disk, but it would be easy to do so with e.gfs.writeFile.\n */\nclass File {\n\n    /**\n     * Constructor\n     *\n     * https://w3c.github.io/FileAPI/#file-constructor\n     *\n     * @param {String|Array|ArrayBuffer|Buffer|[File]} bits - file content\n     * @param {String} name (optional) - file name\n     * @param {Object} stats (optional) - file stats e.g. lastModified\n     */\n    constructor(data, name=\"\", stats={}) {\n\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n\n        const buffers = data.map((d) => {\n            if (d instanceof File) {\n                return Buffer.from(d.data);\n            }\n\n            if (d instanceof ArrayBuffer) {\n                return Buffer.from(d);\n            }\n\n            return Buffer.from(d);\n        });\n        const totalLength = buffers.reduce((p, c) => p + c.length, 0);\n        this.data = Buffer.concat(buffers, totalLength);\n\n        this.name = name;\n        this.lastModified = stats.lastModified || Date.now();\n\n        const types = (0,_core_lib_FileType_mjs__WEBPACK_IMPORTED_MODULE_0__.detectFileType)(this.data);\n        if (types.length) {\n            this.type = types[0].mime;\n        } else {\n            this.type = \"application/unknown\";\n        }\n    }\n\n    /**\n     * size property\n     */\n    get size() {\n        return this.data.length;\n    }\n\n    /**\n     * Return lastModified as Date\n     */\n    get lastModifiedDate() {\n        return new Date(this.lastModified);\n    }\n\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (File);\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/cyberchef/src/node/File.mjs?\n}");

/***/ }),

/***/ "./node_modules/loglevel/lib/loglevel.js":
/*!***********************************************!*\
  !*** ./node_modules/loglevel/lib/loglevel.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("{var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else // removed by dead control flow\n{}\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/loglevel/lib/loglevel.js?\n}");

/***/ }),

/***/ "./node_modules/utf8/utf8.js":
/*!***********************************!*\
  !*** ./node_modules/utf8/utf8.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("{/*! https://mths.be/utf8js v3.0.0 by @mathias */\n;(function(root) {\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2decode(string) {\n\t\tvar output = [];\n\t\tvar counter = 0;\n\t\tvar length = string.length;\n\t\tvar value;\n\t\tvar extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t// Taken from https://mths.be/punycode\n\tfunction ucs2encode(array) {\n\t\tvar length = array.length;\n\t\tvar index = -1;\n\t\tvar value;\n\t\tvar output = '';\n\t\twhile (++index < length) {\n\t\t\tvalue = array[index];\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t}\n\t\treturn output;\n\t}\n\n\tfunction checkScalarValue(codePoint) {\n\t\tif (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n\t\t\tthrow Error(\n\t\t\t\t'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +\n\t\t\t\t' is not a scalar value'\n\t\t\t);\n\t\t}\n\t}\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction createByte(codePoint, shift) {\n\t\treturn stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);\n\t}\n\n\tfunction encodeCodePoint(codePoint) {\n\t\tif ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence\n\t\t\treturn stringFromCharCode(codePoint);\n\t\t}\n\t\tvar symbol = '';\n\t\tif ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);\n\t\t}\n\t\telse if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence\n\t\t\tcheckScalarValue(codePoint);\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\telse if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence\n\t\t\tsymbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);\n\t\t\tsymbol += createByte(codePoint, 12);\n\t\t\tsymbol += createByte(codePoint, 6);\n\t\t}\n\t\tsymbol += stringFromCharCode((codePoint & 0x3F) | 0x80);\n\t\treturn symbol;\n\t}\n\n\tfunction utf8encode(string) {\n\t\tvar codePoints = ucs2decode(string);\n\t\tvar length = codePoints.length;\n\t\tvar index = -1;\n\t\tvar codePoint;\n\t\tvar byteString = '';\n\t\twhile (++index < length) {\n\t\t\tcodePoint = codePoints[index];\n\t\t\tbyteString += encodeCodePoint(codePoint);\n\t\t}\n\t\treturn byteString;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tfunction readContinuationByte() {\n\t\tif (byteIndex >= byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tvar continuationByte = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\tif ((continuationByte & 0xC0) == 0x80) {\n\t\t\treturn continuationByte & 0x3F;\n\t\t}\n\n\t\t// If we end up here, it’s not a continuation byte\n\t\tthrow Error('Invalid continuation byte');\n\t}\n\n\tfunction decodeSymbol() {\n\t\tvar byte1;\n\t\tvar byte2;\n\t\tvar byte3;\n\t\tvar byte4;\n\t\tvar codePoint;\n\n\t\tif (byteIndex > byteCount) {\n\t\t\tthrow Error('Invalid byte index');\n\t\t}\n\n\t\tif (byteIndex == byteCount) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Read first byte\n\t\tbyte1 = byteArray[byteIndex] & 0xFF;\n\t\tbyteIndex++;\n\n\t\t// 1-byte sequence (no continuation bytes)\n\t\tif ((byte1 & 0x80) == 0) {\n\t\t\treturn byte1;\n\t\t}\n\n\t\t// 2-byte sequence\n\t\tif ((byte1 & 0xE0) == 0xC0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x1F) << 6) | byte2;\n\t\t\tif (codePoint >= 0x80) {\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 3-byte sequence (may include unpaired surrogates)\n\t\tif ((byte1 & 0xF0) == 0xE0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;\n\t\t\tif (codePoint >= 0x0800) {\n\t\t\t\tcheckScalarValue(codePoint);\n\t\t\t\treturn codePoint;\n\t\t\t} else {\n\t\t\t\tthrow Error('Invalid continuation byte');\n\t\t\t}\n\t\t}\n\n\t\t// 4-byte sequence\n\t\tif ((byte1 & 0xF8) == 0xF0) {\n\t\t\tbyte2 = readContinuationByte();\n\t\t\tbyte3 = readContinuationByte();\n\t\t\tbyte4 = readContinuationByte();\n\t\t\tcodePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |\n\t\t\t\t(byte3 << 0x06) | byte4;\n\t\t\tif (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {\n\t\t\t\treturn codePoint;\n\t\t\t}\n\t\t}\n\n\t\tthrow Error('Invalid UTF-8 detected');\n\t}\n\n\tvar byteArray;\n\tvar byteCount;\n\tvar byteIndex;\n\tfunction utf8decode(byteString) {\n\t\tbyteArray = ucs2decode(byteString);\n\t\tbyteCount = byteArray.length;\n\t\tbyteIndex = 0;\n\t\tvar codePoints = [];\n\t\tvar tmp;\n\t\twhile ((tmp = decodeSymbol()) !== false) {\n\t\t\tcodePoints.push(tmp);\n\t\t}\n\t\treturn ucs2encode(codePoints);\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\troot.version = '3.0.0';\n\troot.encode = utf8encode;\n\troot.decode = utf8decode;\n\n}( false ? 0 : exports));\n\n\n//# sourceURL=webpack://frida-ui/./node_modules/utf8/utf8.js?\n}");

/***/ })

}]);